"use strict"
Object.defineProperty(exports, "__esModule", { value: !0 })
var e = []
Object.freeze(e)
var t = {}
function r() {
    return ++Ce.mobxGuid
}
function n(e) {
    throw (o(!1, e), "X")
}
function o(e, t) {
    if (!e)
        throw new Error(
            "[mobx] " +
                (t ||
                    "An invariant failed, however the error is obfuscated because this is a production build.")
        )
}
function i(e) {
    var t = !1
    return function() {
        if (!t) return (t = !0), e.apply(this, arguments)
    }
}
Object.freeze(t)
var a = function() {}
function s(e) {
    return null !== e && "object" == typeof e
}
function u(e) {
    if (null === e || "object" != typeof e) return !1
    var t = Object.getPrototypeOf(e)
    return t === Object.prototype || null === t
}
function c(e, t, r) {
    Object.defineProperty(e, t, { enumerable: !1, writable: !0, configurable: !0, value: r })
}
function l(e, t) {
    var r = "isMobX" + e
    return (
        (t.prototype[r] = !0),
        function(e) {
            return s(e) && !0 === e[r]
        }
    )
}
function f(e) {
    return e instanceof Map
}
function p(e) {
    return e instanceof Set
}
function h(e) {
    var t = new Set()
    for (var r in e) t.add(r)
    return (
        Object.getOwnPropertySymbols(e).forEach(function(r) {
            Object.getOwnPropertyDescriptor(e, r).enumerable && t.add(r)
        }),
        Array.from(t)
    )
}
function d(e) {
    return e && e.toString ? e.toString() : new String(e).toString()
}
function v(e) {
    return null === e ? null : "object" == typeof e ? "" + e : e
}
var y = Symbol("mobx administration"),
    b = (function() {
        function e(e) {
            void 0 === e && (e = "Atom@" + r()),
                (this.name = e),
                (this.isPendingUnobservation = !1),
                (this.isBeingObserved = !1),
                (this.observers = new Set()),
                (this.diffValue = 0),
                (this.lastAccessedBy = 0),
                (this.lowestObserverState = exports.IDerivationState.NOT_TRACKING)
        }
        return (
            (e.prototype.onBecomeObserved = function() {
                this.onBecomeObservedListeners &&
                    this.onBecomeObservedListeners.forEach(function(e) {
                        return e()
                    })
            }),
            (e.prototype.onBecomeUnobserved = function() {
                this.onBecomeUnobservedListeners &&
                    this.onBecomeUnobservedListeners.forEach(function(e) {
                        return e()
                    })
            }),
            (e.prototype.reportObserved = function() {
                return Ne(this)
            }),
            (e.prototype.reportChanged = function() {
                Pe(),
                    (function(e) {
                        if (e.lowestObserverState === exports.IDerivationState.STALE) return
                        ;(e.lowestObserverState = exports.IDerivationState.STALE),
                            e.observers.forEach(function(t) {
                                t.dependenciesState === exports.IDerivationState.UP_TO_DATE &&
                                    (t.isTracing !== X.NONE && Ve(t, e), t.onBecomeStale()),
                                    (t.dependenciesState = exports.IDerivationState.STALE)
                            })
                    })(this),
                    ke()
            }),
            (e.prototype.toString = function() {
                return this.name
            }),
            e
        )
    })(),
    g = l("Atom", b)
function m(e, t, r) {
    void 0 === t && (t = a), void 0 === r && (r = a)
    var n = new b(e)
    return t !== a && Ze(n, t), r !== a && et(n, r), n
}
var w = {
        identity: function(e, t) {
            return e === t
        },
        structural: function(e, t) {
            return ar(e, t)
        },
        default: function(e, t) {
            return Object.is(e, t)
        },
        shallow: function(e, t) {
            return ar(e, t, 1)
        }
    },
    x = function(e, t) {
        return (x =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
                function(e, t) {
                    e.__proto__ = t
                }) ||
            function(e, t) {
                for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
            })(e, t)
    }
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */ var O = function() {
    return (O =
        Object.assign ||
        function(e) {
            for (var t, r = 1, n = arguments.length; r < n; r++)
                for (var o in (t = arguments[r]))
                    Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o])
            return e
        }).apply(this, arguments)
}
function S(e) {
    var t = "function" == typeof Symbol && e[Symbol.iterator],
        r = 0
    return t
        ? t.call(e)
        : {
              next: function() {
                  return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }
              }
          }
}
function A(e, t) {
    var r = "function" == typeof Symbol && e[Symbol.iterator]
    if (!r) return e
    var n,
        o,
        i = r.call(e),
        a = []
    try {
        for (; (void 0 === t || t-- > 0) && !(n = i.next()).done; ) a.push(n.value)
    } catch (e) {
        o = { error: e }
    } finally {
        try {
            n && !n.done && (r = i.return) && r.call(i)
        } finally {
            if (o) throw o.error
        }
    }
    return a
}
function _() {
    for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(A(arguments[t]))
    return e
}
var E = Symbol("mobx did run lazy initializers"),
    D = Symbol("mobx pending decorators"),
    j = {},
    C = {}
function R(e, t) {
    var r = t ? j : C
    return (
        r[e] ||
        (r[e] = {
            configurable: !0,
            enumerable: t,
            get: function() {
                return T(this), this[e]
            },
            set: function(t) {
                T(this), (this[e] = t)
            }
        })
    )
}
function T(e) {
    var t, r
    if (!0 !== e[E]) {
        var n = e[D]
        if (n) {
            c(e, E, !0)
            var o = _(Object.getOwnPropertySymbols(n), Object.keys(n))
            try {
                for (var i = S(o), a = i.next(); !a.done; a = i.next()) {
                    var s = n[a.value]
                    s.propertyCreator(
                        e,
                        s.prop,
                        s.descriptor,
                        s.decoratorTarget,
                        s.decoratorArguments
                    )
                }
            } catch (e) {
                t = { error: e }
            } finally {
                try {
                    a && !a.done && (r = i.return) && r.call(i)
                } finally {
                    if (t) throw t.error
                }
            }
        }
    }
}
function I(t, r) {
    return function() {
        var n,
            o = function(e, o, i, a) {
                if (!0 === a) return r(e, o, i, e, n), null
                if (!Object.prototype.hasOwnProperty.call(e, D)) {
                    var s = e[D]
                    c(e, D, O({}, s))
                }
                return (
                    (e[D][o] = {
                        prop: o,
                        propertyCreator: r,
                        descriptor: i,
                        decoratorTarget: e,
                        decoratorArguments: n
                    }),
                    R(o, t)
                )
            }
        return P(arguments)
            ? ((n = e), o.apply(null, arguments))
            : ((n = Array.prototype.slice.call(arguments)), o)
    }
}
function P(e) {
    return (
        ((2 === e.length || 3 === e.length) &&
            ("string" == typeof e[1] || "symbol" == typeof e[1])) ||
        (4 === e.length && !0 === e[3])
    )
}
function k(e, t, r) {
    return dt(e)
        ? e
        : Array.isArray(e)
        ? H.array(e, { name: r })
        : u(e)
        ? H.object(e, void 0, { name: r })
        : f(e)
        ? H.map(e, { name: r })
        : p(e)
        ? H.set(e, { name: r })
        : e
}
function N(e) {
    return e
}
function V(e) {
    o(e)
    var t = I(!0, function(t, r, n, o, i) {
            var a = n ? (n.initializer ? n.initializer.call(t) : n.value) : void 0
            Ft(t).addObservableProp(r, a, e)
        }),
        r = ("undefined" != typeof process && process.env, t)
    return (r.enhancer = e), r
}
var B = { deep: !0, name: void 0, defaultDecorator: void 0, proxy: !0 }
function L(e) {
    return null == e ? B : "string" == typeof e ? { name: e, deep: !0, proxy: !0 } : e
}
Object.freeze(B)
var M = V(k),
    U = V(function(e, t, r) {
        return null == e
            ? e
            : tr(e) || Gt(e) || Ht(e) || Xt(e)
            ? e
            : Array.isArray(e)
            ? H.array(e, { name: r, deep: !1 })
            : u(e)
            ? H.object(e, void 0, { name: r, deep: !1 })
            : f(e)
            ? H.map(e, { name: r, deep: !1 })
            : p(e)
            ? H.set(e, { name: r, deep: !1 })
            : n(!1)
    }),
    G = V(N),
    q = V(function(e, t, r) {
        return ar(e, t) ? t : e
    })
function z(e) {
    return e.defaultDecorator ? e.defaultDecorator.enhancer : !1 === e.deep ? N : k
}
var K = {
        box: function(e, t) {
            arguments.length > 2 && W("box")
            var r = L(t)
            return new me(e, z(r), r.name, !0, r.equals)
        },
        array: function(e, t) {
            arguments.length > 2 && W("array")
            var r = L(t)
            return Vt(e, z(r), r.name)
        },
        map: function(e, t) {
            arguments.length > 2 && W("map")
            var r = L(t)
            return new Kt(e, z(r), r.name)
        },
        set: function(e, t) {
            arguments.length > 2 && W("set")
            var r = L(t)
            return new Jt(e, z(r), r.name)
        },
        object: function(e, t, r) {
            "string" == typeof arguments[1] && W("object")
            var n = L(r)
            if (!1 === n.proxy) return rt({}, e, t, n)
            var o = nt(n),
                i = rt({}, void 0, void 0, n),
                a = jt(i)
            return ot(a, e, t, o), a
        },
        ref: G,
        shallow: U,
        deep: M,
        struct: q
    },
    H = function(e, t, r) {
        if ("string" == typeof arguments[1] || "symbol" == typeof arguments[1])
            return M.apply(null, arguments)
        if (dt(e)) return e
        var o = u(e)
            ? H.object(e, t, r)
            : Array.isArray(e)
            ? H.array(e, t)
            : f(e)
            ? H.map(e, t)
            : p(e)
            ? H.set(e, t)
            : e
        if (o !== e) return o
        n(!1)
    }
function W(e) {
    n(
        "Expected one or two arguments to observable." +
            e +
            ". Did you accidentally try to use observable." +
            e +
            " as decorator?"
    )
}
Object.keys(K).forEach(function(e) {
    return (H[e] = K[e])
})
var J,
    X,
    Y = I(!1, function(e, t, r, n, o) {
        var i = r.get,
            a = r.set,
            s = o[0] || {}
        Ft(e).addComputedProp(e, t, O({ get: i, set: a, context: e }, s))
    }),
    F = Y({ equals: w.structural }),
    $ = function(e, t, r) {
        if ("string" == typeof t) return Y.apply(null, arguments)
        if (null !== e && "object" == typeof e && 1 === arguments.length)
            return Y.apply(null, arguments)
        var n = "object" == typeof t ? t : {}
        return (
            (n.get = e),
            (n.set = "function" == typeof t ? t : n.set),
            (n.name = n.name || e.name || ""),
            new xe(n)
        )
    }
;($.struct = F),
    ((J = exports.IDerivationState || (exports.IDerivationState = {}))[(J.NOT_TRACKING = -1)] =
        "NOT_TRACKING"),
    (J[(J.UP_TO_DATE = 0)] = "UP_TO_DATE"),
    (J[(J.POSSIBLY_STALE = 1)] = "POSSIBLY_STALE"),
    (J[(J.STALE = 2)] = "STALE"),
    (function(e) {
        ;(e[(e.NONE = 0)] = "NONE"), (e[(e.LOG = 1)] = "LOG"), (e[(e.BREAK = 2)] = "BREAK")
    })(X || (X = {}))
var Q = function(e) {
    this.cause = e
}
function Z(e) {
    return e instanceof Q
}
function ee(e) {
    switch (e.dependenciesState) {
        case exports.IDerivationState.UP_TO_DATE:
            return !1
        case exports.IDerivationState.NOT_TRACKING:
        case exports.IDerivationState.STALE:
            return !0
        case exports.IDerivationState.POSSIBLY_STALE:
            for (var t = se(!0), r = ie(), n = e.observing, o = n.length, i = 0; i < o; i++) {
                var a = n[i]
                if (Oe(a)) {
                    if (Ce.disableErrorBoundaries) a.get()
                    else
                        try {
                            a.get()
                        } catch (e) {
                            return ae(r), ue(t), !0
                        }
                    if (e.dependenciesState === exports.IDerivationState.STALE)
                        return ae(r), ue(t), !0
                }
            }
            return ce(e), ae(r), ue(t), !1
    }
}
function te(e) {
    var t = e.observers.size > 0
    Ce.computationDepth > 0 && t && n(!1),
        Ce.allowStateChanges || (!t && "strict" !== Ce.enforceActions) || n(!1)
}
function re(e, t, r) {
    var n = se(!0)
    ce(e),
        (e.newObserving = new Array(e.observing.length + 100)),
        (e.unboundDepsCount = 0),
        (e.runId = ++Ce.runId)
    var o,
        i = Ce.trackingDerivation
    if (((Ce.trackingDerivation = e), !0 === Ce.disableErrorBoundaries)) o = t.call(r)
    else
        try {
            o = t.call(r)
        } catch (e) {
            o = new Q(e)
        }
    return (
        (Ce.trackingDerivation = i),
        (function(e) {
            for (
                var t = e.observing,
                    r = (e.observing = e.newObserving),
                    n = exports.IDerivationState.UP_TO_DATE,
                    o = 0,
                    i = e.unboundDepsCount,
                    a = 0;
                a < i;
                a++
            ) {
                0 === (s = r[a]).diffValue && ((s.diffValue = 1), o !== a && (r[o] = s), o++),
                    s.dependenciesState > n && (n = s.dependenciesState)
            }
            ;(r.length = o), (e.newObserving = null), (i = t.length)
            for (; i--; ) {
                0 === (s = t[i]).diffValue && Te(s, e), (s.diffValue = 0)
            }
            for (; o--; ) {
                var s
                1 === (s = r[o]).diffValue && ((s.diffValue = 0), Re(s, e))
            }
            n !== exports.IDerivationState.UP_TO_DATE &&
                ((e.dependenciesState = n), e.onBecomeStale())
        })(e),
        ue(n),
        o
    )
}
function ne(e) {
    var t = e.observing
    e.observing = []
    for (var r = t.length; r--; ) Te(t[r], e)
    e.dependenciesState = exports.IDerivationState.NOT_TRACKING
}
function oe(e) {
    var t = ie()
    try {
        return e()
    } finally {
        ae(t)
    }
}
function ie() {
    var e = Ce.trackingDerivation
    return (Ce.trackingDerivation = null), e
}
function ae(e) {
    Ce.trackingDerivation = e
}
function se(e) {
    var t = Ce.allowStateReads
    return (Ce.allowStateReads = e), t
}
function ue(e) {
    Ce.allowStateReads = e
}
function ce(e) {
    if (e.dependenciesState !== exports.IDerivationState.UP_TO_DATE) {
        e.dependenciesState = exports.IDerivationState.UP_TO_DATE
        for (var t = e.observing, r = t.length; r--; )
            t[r].lowestObserverState = exports.IDerivationState.UP_TO_DATE
    }
}
var le = 0,
    fe = 1,
    pe = Object.getOwnPropertyDescriptor(function() {}, "name")
pe && pe.configurable
function he(e, t, r) {
    var n = function() {
        return de(e, t, r || this, arguments)
    }
    return (n.isMobxAction = !0), n
}
function de(e, t, r, n) {
    var o = ve()
    try {
        return t.apply(r, n)
    } catch (e) {
        throw ((o.error = e), e)
    } finally {
        ye(o)
    }
}
function ve(e, t, r) {
    var n = ie()
    Pe()
    var o = {
        prevDerivation: n,
        prevAllowStateChanges: be(!0),
        prevAllowStateReads: se(!0),
        notifySpy: !1,
        startTime: 0,
        actionId: fe++,
        parentActionId: le
    }
    return (le = o.actionId), o
}
function ye(e) {
    le !== e.actionId && n("invalid action stack. did you forget to finish an action?"),
        (le = e.parentActionId),
        void 0 !== e.error && (Ce.suppressReactionErrors = !0),
        ge(e.prevAllowStateChanges),
        ue(e.prevAllowStateReads),
        ke(),
        ae(e.prevDerivation),
        e.notifySpy,
        (Ce.suppressReactionErrors = !1)
}
function be(e) {
    var t = Ce.allowStateChanges
    return (Ce.allowStateChanges = e), t
}
function ge(e) {
    Ce.allowStateChanges = e
}
var me = (function(e) {
        function t(t, n, o, i, a) {
            void 0 === o && (o = "ObservableValue@" + r()),
                void 0 === i && (i = !0),
                void 0 === a && (a = w.default)
            var s = e.call(this, o) || this
            return (
                (s.enhancer = n),
                (s.name = o),
                (s.equals = a),
                (s.hasUnreportedChange = !1),
                (s.value = n(t, void 0, o)),
                s
            )
        }
        return (
            (function(e, t) {
                function r() {
                    this.constructor = e
                }
                x(e, t),
                    (e.prototype =
                        null === t ? Object.create(t) : ((r.prototype = t.prototype), new r()))
            })(t, e),
            (t.prototype.dehanceValue = function(e) {
                return void 0 !== this.dehancer ? this.dehancer(e) : e
            }),
            (t.prototype.set = function(e) {
                this.value
                if ((e = this.prepareNewValue(e)) !== Ce.UNCHANGED) {
                    0, this.setNewValue(e)
                }
            }),
            (t.prototype.prepareNewValue = function(e) {
                if ((te(this), Ct(this))) {
                    var t = Tt(this, { object: this, type: "update", newValue: e })
                    if (!t) return Ce.UNCHANGED
                    e = t.newValue
                }
                return (
                    (e = this.enhancer(e, this.value, this.name)),
                    this.equals(this.value, e) ? Ce.UNCHANGED : e
                )
            }),
            (t.prototype.setNewValue = function(e) {
                var t = this.value
                ;(this.value = e),
                    this.reportChanged(),
                    It(this) && kt(this, { type: "update", object: this, newValue: e, oldValue: t })
            }),
            (t.prototype.get = function() {
                return this.reportObserved(), this.dehanceValue(this.value)
            }),
            (t.prototype.intercept = function(e) {
                return Rt(this, e)
            }),
            (t.prototype.observe = function(e, t) {
                return (
                    t &&
                        e({ object: this, type: "update", newValue: this.value, oldValue: void 0 }),
                    Pt(this, e)
                )
            }),
            (t.prototype.toJSON = function() {
                return this.get()
            }),
            (t.prototype.toString = function() {
                return this.name + "[" + this.value + "]"
            }),
            (t.prototype.valueOf = function() {
                return v(this.get())
            }),
            (t.prototype[Symbol.toPrimitive] = function() {
                return this.valueOf()
            }),
            t
        )
    })(b),
    we = l("ObservableValue", me),
    xe = (function() {
        function e(e) {
            ;(this.dependenciesState = exports.IDerivationState.NOT_TRACKING),
                (this.observing = []),
                (this.newObserving = null),
                (this.isBeingObserved = !1),
                (this.isPendingUnobservation = !1),
                (this.observers = new Set()),
                (this.diffValue = 0),
                (this.runId = 0),
                (this.lastAccessedBy = 0),
                (this.lowestObserverState = exports.IDerivationState.UP_TO_DATE),
                (this.unboundDepsCount = 0),
                (this.__mapid = "#" + r()),
                (this.value = new Q(null)),
                (this.isComputing = !1),
                (this.isRunningSetter = !1),
                (this.isTracing = X.NONE),
                o(e.get, "missing option for computed: get"),
                (this.derivation = e.get),
                (this.name = e.name || "ComputedValue@" + r()),
                e.set && (this.setter = he(this.name + "-setter", e.set)),
                (this.equals =
                    e.equals || (e.compareStructural || e.struct ? w.structural : w.default)),
                (this.scope = e.context),
                (this.requiresReaction = !!e.requiresReaction),
                (this.keepAlive = !!e.keepAlive)
        }
        return (
            (e.prototype.onBecomeStale = function() {
                !(function(e) {
                    if (e.lowestObserverState !== exports.IDerivationState.UP_TO_DATE) return
                    ;(e.lowestObserverState = exports.IDerivationState.POSSIBLY_STALE),
                        e.observers.forEach(function(t) {
                            t.dependenciesState === exports.IDerivationState.UP_TO_DATE &&
                                ((t.dependenciesState = exports.IDerivationState.POSSIBLY_STALE),
                                t.isTracing !== X.NONE && Ve(t, e),
                                t.onBecomeStale())
                        })
                })(this)
            }),
            (e.prototype.onBecomeObserved = function() {
                this.onBecomeObservedListeners &&
                    this.onBecomeObservedListeners.forEach(function(e) {
                        return e()
                    })
            }),
            (e.prototype.onBecomeUnobserved = function() {
                this.onBecomeUnobservedListeners &&
                    this.onBecomeUnobservedListeners.forEach(function(e) {
                        return e()
                    })
            }),
            (e.prototype.get = function() {
                this.isComputing &&
                    n("Cycle detected in computation " + this.name + ": " + this.derivation),
                    0 !== Ce.inBatch || 0 !== this.observers.size || this.keepAlive
                        ? (Ne(this),
                          ee(this) &&
                              this.trackAndCompute() &&
                              (function(e) {
                                  if (e.lowestObserverState === exports.IDerivationState.STALE)
                                      return
                                  ;(e.lowestObserverState = exports.IDerivationState.STALE),
                                      e.observers.forEach(function(t) {
                                          t.dependenciesState ===
                                          exports.IDerivationState.POSSIBLY_STALE
                                              ? (t.dependenciesState =
                                                    exports.IDerivationState.STALE)
                                              : t.dependenciesState ===
                                                    exports.IDerivationState.UP_TO_DATE &&
                                                (e.lowestObserverState =
                                                    exports.IDerivationState.UP_TO_DATE)
                                      })
                              })(this))
                        : ee(this) &&
                          (this.warnAboutUntrackedRead(),
                          Pe(),
                          (this.value = this.computeValue(!1)),
                          ke())
                var e = this.value
                if (Z(e)) throw e.cause
                return e
            }),
            (e.prototype.peek = function() {
                var e = this.computeValue(!1)
                if (Z(e)) throw e.cause
                return e
            }),
            (e.prototype.set = function(e) {
                if (this.setter) {
                    o(
                        !this.isRunningSetter,
                        "The setter of computed value '" +
                            this.name +
                            "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?"
                    ),
                        (this.isRunningSetter = !0)
                    try {
                        this.setter.call(this.scope, e)
                    } finally {
                        this.isRunningSetter = !1
                    }
                } else o(!1, !1)
            }),
            (e.prototype.trackAndCompute = function() {
                var e = this.value,
                    t = this.dependenciesState === exports.IDerivationState.NOT_TRACKING,
                    r = this.computeValue(!0),
                    n = t || Z(e) || Z(r) || !this.equals(e, r)
                return n && (this.value = r), n
            }),
            (e.prototype.computeValue = function(e) {
                var t
                if (((this.isComputing = !0), Ce.computationDepth++, e))
                    t = re(this, this.derivation, this.scope)
                else if (!0 === Ce.disableErrorBoundaries) t = this.derivation.call(this.scope)
                else
                    try {
                        t = this.derivation.call(this.scope)
                    } catch (e) {
                        t = new Q(e)
                    }
                return Ce.computationDepth--, (this.isComputing = !1), t
            }),
            (e.prototype.suspend = function() {
                this.keepAlive || (ne(this), (this.value = void 0))
            }),
            (e.prototype.observe = function(e, t) {
                var r = this,
                    n = !0,
                    o = void 0
                return Fe(function() {
                    var i = r.get()
                    if (!n || t) {
                        var a = ie()
                        e({ type: "update", object: r, newValue: i, oldValue: o }), ae(a)
                    }
                    ;(n = !1), (o = i)
                })
            }),
            (e.prototype.warnAboutUntrackedRead = function() {}),
            (e.prototype.toJSON = function() {
                return this.get()
            }),
            (e.prototype.toString = function() {
                return this.name + "[" + this.derivation.toString() + "]"
            }),
            (e.prototype.valueOf = function() {
                return v(this.get())
            }),
            (e.prototype[Symbol.toPrimitive] = function() {
                return this.valueOf()
            }),
            e
        )
    })(),
    Oe = l("ComputedValue", xe),
    Se = [
        "mobxGuid",
        "spyListeners",
        "enforceActions",
        "computedRequiresReaction",
        "reactionRequiresObservable",
        "observableRequiresReaction",
        "allowStateReads",
        "disableErrorBoundaries",
        "runId",
        "UNCHANGED"
    ],
    Ae = function() {
        ;(this.version = 5),
            (this.UNCHANGED = {}),
            (this.trackingDerivation = null),
            (this.computationDepth = 0),
            (this.runId = 0),
            (this.mobxGuid = 0),
            (this.inBatch = 0),
            (this.pendingUnobservations = []),
            (this.pendingReactions = []),
            (this.isRunningReactions = !1),
            (this.allowStateChanges = !0),
            (this.allowStateReads = !0),
            (this.enforceActions = !1),
            (this.spyListeners = []),
            (this.globalReactionErrorHandlers = []),
            (this.computedRequiresReaction = !1),
            (this.reactionRequiresObservable = !1),
            (this.observableRequiresReaction = !1),
            (this.computedConfigurable = !1),
            (this.disableErrorBoundaries = !1),
            (this.suppressReactionErrors = !1)
    },
    _e = {}
function Ee() {
    return "undefined" != typeof window
        ? window
        : "undefined" != typeof global
        ? global
        : "undefined" != typeof self
        ? self
        : _e
}
var De = !0,
    je = !1,
    Ce = (function() {
        var e = Ee()
        return (
            e.__mobxInstanceCount > 0 && !e.__mobxGlobals && (De = !1),
            e.__mobxGlobals && e.__mobxGlobals.version !== new Ae().version && (De = !1),
            De
                ? e.__mobxGlobals
                    ? ((e.__mobxInstanceCount += 1),
                      e.__mobxGlobals.UNCHANGED || (e.__mobxGlobals.UNCHANGED = {}),
                      e.__mobxGlobals)
                    : ((e.__mobxInstanceCount = 1), (e.__mobxGlobals = new Ae()))
                : (setTimeout(function() {
                      je ||
                          n(
                              "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`"
                          )
                  }, 1),
                  new Ae())
        )
    })()
function Re(e, t) {
    e.observers.add(t),
        e.lowestObserverState > t.dependenciesState && (e.lowestObserverState = t.dependenciesState)
}
function Te(e, t) {
    e.observers.delete(t), 0 === e.observers.size && Ie(e)
}
function Ie(e) {
    !1 === e.isPendingUnobservation &&
        ((e.isPendingUnobservation = !0), Ce.pendingUnobservations.push(e))
}
function Pe() {
    Ce.inBatch++
}
function ke() {
    if (0 == --Ce.inBatch) {
        Ue()
        for (var e = Ce.pendingUnobservations, t = 0; t < e.length; t++) {
            var r = e[t]
            ;(r.isPendingUnobservation = !1),
                0 === r.observers.size &&
                    (r.isBeingObserved && ((r.isBeingObserved = !1), r.onBecomeUnobserved()),
                    r instanceof xe && r.suspend())
        }
        Ce.pendingUnobservations = []
    }
}
function Ne(e) {
    var t = Ce.trackingDerivation
    return null !== t
        ? (t.runId !== e.lastAccessedBy &&
              ((e.lastAccessedBy = t.runId),
              (t.newObserving[t.unboundDepsCount++] = e),
              e.isBeingObserved || ((e.isBeingObserved = !0), e.onBecomeObserved())),
          !0)
        : (0 === e.observers.size && Ce.inBatch > 0 && Ie(e), !1)
}
function Ve(e, t) {
    if (
        (console.log(
            "[mobx.trace] '" + e.name + "' is invalidated due to a change in: '" + t.name + "'"
        ),
        e.isTracing === X.BREAK)
    ) {
        var r = []
        !(function e(t, r, n) {
            if (r.length >= 1e3) return void r.push("(and many more)")
            r.push("" + new Array(n).join("\t") + t.name),
                t.dependencies &&
                    t.dependencies.forEach(function(t) {
                        return e(t, r, n + 1)
                    })
        })(it(e), r, 1),
            new Function(
                "debugger;\n/*\nTracing '" +
                    e.name +
                    "'\n\nYou are entering this break point because derivation '" +
                    e.name +
                    "' is being traced and '" +
                    t.name +
                    "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" +
                    (e instanceof xe ? e.derivation.toString().replace(/[*]\//g, "/") : "") +
                    "\n\nThe dependencies for this derivation are:\n\n" +
                    r.join("\n") +
                    "\n*/\n    "
            )()
    }
}
var Be = (function() {
    function e(e, t, n, o) {
        void 0 === e && (e = "Reaction@" + r()),
            void 0 === o && (o = !1),
            (this.name = e),
            (this.onInvalidate = t),
            (this.errorHandler = n),
            (this.requiresObservable = o),
            (this.observing = []),
            (this.newObserving = []),
            (this.dependenciesState = exports.IDerivationState.NOT_TRACKING),
            (this.diffValue = 0),
            (this.runId = 0),
            (this.unboundDepsCount = 0),
            (this.__mapid = "#" + r()),
            (this.isDisposed = !1),
            (this._isScheduled = !1),
            (this._isTrackPending = !1),
            (this._isRunning = !1),
            (this.isTracing = X.NONE)
    }
    return (
        (e.prototype.onBecomeStale = function() {
            this.schedule()
        }),
        (e.prototype.schedule = function() {
            this._isScheduled || ((this._isScheduled = !0), Ce.pendingReactions.push(this), Ue())
        }),
        (e.prototype.isScheduled = function() {
            return this._isScheduled
        }),
        (e.prototype.runReaction = function() {
            if (!this.isDisposed) {
                if ((Pe(), (this._isScheduled = !1), ee(this))) {
                    this._isTrackPending = !0
                    try {
                        this.onInvalidate(), this._isTrackPending
                    } catch (e) {
                        this.reportExceptionInDerivation(e)
                    }
                }
                ke()
            }
        }),
        (e.prototype.track = function(e) {
            if (!this.isDisposed) {
                Pe(), (this._isRunning = !0)
                var t = re(this, e, void 0)
                ;(this._isRunning = !1),
                    (this._isTrackPending = !1),
                    this.isDisposed && ne(this),
                    Z(t) && this.reportExceptionInDerivation(t.cause),
                    ke()
            }
        }),
        (e.prototype.reportExceptionInDerivation = function(e) {
            var t = this
            if (this.errorHandler) this.errorHandler(e, this)
            else {
                if (Ce.disableErrorBoundaries) throw e
                var r =
                    "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" +
                    this +
                    "'"
                Ce.suppressReactionErrors
                    ? console.warn(
                          "[mobx] (error in reaction '" +
                              this.name +
                              "' suppressed, fix error of causing action below)"
                      )
                    : console.error(r, e),
                    Ce.globalReactionErrorHandlers.forEach(function(r) {
                        return r(e, t)
                    })
            }
        }),
        (e.prototype.dispose = function() {
            this.isDisposed || ((this.isDisposed = !0), this._isRunning || (Pe(), ne(this), ke()))
        }),
        (e.prototype.getDisposer = function() {
            var e = this.dispose.bind(this)
            return (e[y] = this), e
        }),
        (e.prototype.toString = function() {
            return "Reaction[" + this.name + "]"
        }),
        (e.prototype.trace = function(e) {
            void 0 === e && (e = !1), wt(this, e)
        }),
        e
    )
})()
var Le = 0,
    Me = function(e) {
        return e()
    }
function Ue() {
    Ce.inBatch > 0 || Ce.isRunningReactions || Me(Ge)
}
function Ge() {
    Ce.isRunningReactions = !0
    var e = Ce.pendingReactions,
        t = 0
    for (
        e.length > 0 &&
        (0 === Le &&
            Promise.resolve().then(function() {
                Le > 20 &&
                    console.warn(
                        "MOBX WARNING, a sigle microtask loop had " +
                            Le +
                            " reactions (which are caused by changes to observables). Batch these actions with @action or runInAction to gain up to a " +
                            Le +
                            "X performance boost!"
                    ),
                    (Le = 0)
            }),
        Le++);
        e.length > 0;

    ) {
        100 == ++t &&
            (console.error(
                "Reaction doesn't converge to a stable state after 100 iterations. Probably there is a cycle in the reactive function: " +
                    e[0]
            ),
            e.splice(0))
        for (var r = e.splice(0), n = 0, o = r.length; n < o; n++) r[n].runReaction()
    }
    Ce.isRunningReactions = !1
}
var qe = l("Reaction", Be)
function ze(e) {
    var t = Me
    Me = function(r) {
        return e(function() {
            return t(r)
        })
    }
}
function Ke(e) {
    return console.warn("[mobx.spy] Is a no-op in production builds"), function() {}
}
function He() {
    n(!1)
}
function We(e) {
    return function(t, r, n) {
        if (n) {
            if (n.value)
                return { value: he(e, n.value), enumerable: !1, configurable: !0, writable: !0 }
            var o = n.initializer
            return {
                enumerable: !1,
                configurable: !0,
                writable: !0,
                initializer: function() {
                    return he(e, o.call(this))
                }
            }
        }
        return Je(e).apply(this, arguments)
    }
}
function Je(e) {
    return function(t, r, n) {
        Object.defineProperty(t, r, {
            configurable: !0,
            enumerable: !1,
            get: function() {},
            set: function(t) {
                c(this, r, Xe(e, t))
            }
        })
    }
}
var Xe = function(e, t, r, n) {
    return 1 === arguments.length && "function" == typeof e
        ? he(e.name || "<unnamed action>", e)
        : 2 === arguments.length && "function" == typeof t
        ? he(e, t)
        : 1 === arguments.length && "string" == typeof e
        ? We(e)
        : !0 !== n
        ? We(t).apply(null, arguments)
        : void c(e, t, he(e.name || t, r.value, this))
}
function Ye(e, t, r) {
    c(e, t, he(t, r.bind(e)))
}
function Fe(e, n) {
    void 0 === n && (n = t)
    var o,
        i = (n && n.name) || e.name || "Autorun@" + r()
    if (!n.scheduler && !n.delay)
        o = new Be(
            i,
            function() {
                this.track(u)
            },
            n.onError,
            n.requiresObservable
        )
    else {
        var a = Qe(n),
            s = !1
        o = new Be(
            i,
            function() {
                s ||
                    ((s = !0),
                    a(function() {
                        ;(s = !1), o.isDisposed || o.track(u)
                    }))
            },
            n.onError,
            n.requiresObservable
        )
    }
    function u() {
        e(o)
    }
    return o.schedule(), o.getDisposer()
}
Xe.bound = function(e, t, r, n) {
    return !0 === n
        ? (Ye(e, t, r.value), null)
        : r
        ? {
              configurable: !0,
              enumerable: !1,
              get: function() {
                  return Ye(this, t, r.value || r.initializer.call(this)), this[t]
              },
              set: He
          }
        : {
              enumerable: !1,
              configurable: !0,
              set: function(e) {
                  Ye(this, t, e)
              },
              get: function() {}
          }
}
var $e = function(e) {
    return e()
}
function Qe(e) {
    return e.scheduler
        ? e.scheduler
        : e.delay
        ? function(t) {
              return setTimeout(t, e.delay)
          }
        : $e
}
function Ze(e, t, r) {
    return tt("onBecomeObserved", e, t, r)
}
function et(e, t, r) {
    return tt("onBecomeUnobserved", e, t, r)
}
function tt(e, t, r, o) {
    var i = "function" == typeof o ? rr(t, r) : rr(t),
        a = "function" == typeof o ? o : r,
        s = e + "Listeners"
    return (
        i[s] ? i[s].add(a) : (i[s] = new Set([a])),
        "function" != typeof i[e]
            ? n(!1)
            : function() {
                  var e = i[s]
                  e && (e.delete(a), 0 === e.size && delete i[s])
              }
    )
}
function rt(e, t, r, n) {
    var o = nt((n = L(n)))
    return T(e), Ft(e, n.name, o.enhancer), t && ot(e, t, r, o), e
}
function nt(e) {
    return e.defaultDecorator || (!1 === e.deep ? G : M)
}
function ot(e, t, r, n) {
    var o, i
    Pe()
    try {
        var a = h(t)
        try {
            for (var s = S(a), u = s.next(); !u.done; u = s.next()) {
                var c = u.value,
                    l = Object.getOwnPropertyDescriptor(t, c)
                0
                var f = r && c in r ? r[c] : l.get ? Y : n
                0
                var p = f(e, c, l, !0)
                p && Object.defineProperty(e, c, p)
            }
        } catch (e) {
            o = { error: e }
        } finally {
            try {
                u && !u.done && (i = s.return) && i.call(s)
            } finally {
                if (o) throw o.error
            }
        }
    } finally {
        ke()
    }
}
function it(e, t) {
    return at(rr(e, t))
}
function at(e) {
    var t,
        r,
        n = { name: e.name }
    return (
        e.observing &&
            e.observing.length > 0 &&
            (n.dependencies = ((t = e.observing),
            (r = []),
            t.forEach(function(e) {
                ;-1 === r.indexOf(e) && r.push(e)
            }),
            r).map(at)),
        n
    )
}
function st(e) {
    var t = { name: e.name }
    return (
        (function(e) {
            return e.observers && e.observers.size > 0
        })(e) &&
            (t.observers = Array.from(
                (function(e) {
                    return e.observers
                })(e)
            ).map(st)),
        t
    )
}
var ut = 0
function ct() {
    this.message = "FLOW_CANCELLED"
}
function lt(e) {
    "function" == typeof e.cancel && e.cancel()
}
function ft(e, t) {
    if (null == e) return !1
    if (void 0 !== t) {
        if (!1 === tr(e)) return !1
        if (!e[y].values.has(t)) return !1
        var r = rr(e, t)
        return Oe(r)
    }
    return Oe(e)
}
function pt(e) {
    return arguments.length > 1 ? n(!1) : ft(e)
}
function ht(e, t) {
    return (
        null != e &&
        (void 0 !== t ? !!tr(e) && e[y].values.has(t) : tr(e) || !!e[y] || g(e) || qe(e) || Oe(e))
    )
}
function dt(e) {
    return 1 !== arguments.length && n(!1), ht(e)
}
function vt(e) {
    return tr(e)
        ? e[y].getKeys()
        : Ht(e)
        ? Array.from(e.keys())
        : Xt(e)
        ? Array.from(e.keys())
        : Gt(e)
        ? e.map(function(e, t) {
              return t
          })
        : n(!1)
}
function yt(e, t, r) {
    if (2 !== arguments.length || Xt(e))
        if (tr(e)) {
            var i = e[y],
                a = i.values.get(t)
            a ? i.write(t, r) : i.addObservableProp(t, r, i.defaultEnhancer)
        } else if (Ht(e)) e.set(t, r)
        else if (Xt(e)) e.add(t)
        else {
            if (!Gt(e)) return n(!1)
            "number" != typeof t && (t = parseInt(t, 10)),
                o(t >= 0, "Not a valid index: '" + t + "'"),
                Pe(),
                t >= e.length && (e.length = t + 1),
                (e[t] = r),
                ke()
        }
    else {
        Pe()
        var s = t
        try {
            for (var u in s) yt(e, u, s[u])
        } finally {
            ke()
        }
    }
}
function bt(e, t) {
    return tr(e)
        ? nr(e).has(t)
        : Ht(e)
        ? e.has(t)
        : Xt(e)
        ? e.has(t)
        : Gt(e)
        ? t >= 0 && t < e.length
        : n(!1)
}
ct.prototype = Object.create(Error.prototype)
var gt = { detectCycles: !0, exportMapsAsObjects: !0, recurseEverything: !1 }
function mt(e, t, r, n) {
    return n.detectCycles && e.set(t, r), r
}
function wt() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
    var r = !1
    "boolean" == typeof e[e.length - 1] && (r = e.pop())
    var o = xt(e)
    if (!o) return n(!1)
    o.isTracing === X.NONE && console.log("[mobx.trace] '" + o.name + "' tracing enabled"),
        (o.isTracing = r ? X.BREAK : X.LOG)
}
function xt(e) {
    switch (e.length) {
        case 0:
            return Ce.trackingDerivation
        case 1:
            return rr(e[0])
        case 2:
            return rr(e[0], e[1])
    }
}
function Ot(e, t) {
    void 0 === t && (t = void 0), Pe()
    try {
        return e.apply(t)
    } finally {
        ke()
    }
}
function St(e, t, n) {
    var o
    "number" == typeof n.timeout &&
        (o = setTimeout(function() {
            if (!a[y].isDisposed) {
                a()
                var e = new Error("WHEN_TIMEOUT")
                if (!n.onError) throw e
                n.onError(e)
            }
        }, n.timeout)),
        (n.name = n.name || "When@" + r())
    var i = he(n.name + "-effect", t),
        a = Fe(function(t) {
            e() && (t.dispose(), o && clearTimeout(o), i())
        }, n)
    return a
}
function At(e, t) {
    var r,
        n = new Promise(function(n, o) {
            var i = St(e, n, O(O({}, t), { onError: o }))
            r = function() {
                i(), o("WHEN_CANCELLED")
            }
        })
    return (n.cancel = r), n
}
function _t(e) {
    return e[y]
}
function Et(e) {
    return "string" == typeof e || "number" == typeof e || "symbol" == typeof e
}
var Dt = {
    has: function(e, t) {
        if (t === y || "constructor" === t || t === E) return !0
        var r = _t(e)
        return Et(t) ? r.has(t) : t in e
    },
    get: function(e, t) {
        if (t === y || "constructor" === t || t === E) return e[t]
        var r = _t(e),
            n = r.values.get(t)
        if (n instanceof b) {
            var o = n.get()
            return void 0 === o && r.has(t), o
        }
        return Et(t) && r.has(t), e[t]
    },
    set: function(e, t, r) {
        return !!Et(t) && (yt(e, t, r), !0)
    },
    deleteProperty: function(e, t) {
        return !!Et(t) && (_t(e).remove(t), !0)
    },
    ownKeys: function(e) {
        return _t(e).keysAtom.reportObserved(), Reflect.ownKeys(e)
    },
    preventExtensions: function(e) {
        return n("Dynamic observable objects cannot be frozen"), !1
    }
}
function jt(e) {
    var t = new Proxy(e, Dt)
    return (e[y].proxy = t), t
}
function Ct(e) {
    return void 0 !== e.interceptors && e.interceptors.length > 0
}
function Rt(e, t) {
    var r = e.interceptors || (e.interceptors = [])
    return (
        r.push(t),
        i(function() {
            var e = r.indexOf(t)
            ;-1 !== e && r.splice(e, 1)
        })
    )
}
function Tt(e, t) {
    var r = ie()
    try {
        for (
            var n = _(e.interceptors || []), i = 0, a = n.length;
            i < a &&
            (o(
                !(t = n[i](t)) || t.type,
                "Intercept handlers should return nothing or a change object"
            ),
            t);
            i++
        );
        return t
    } finally {
        ae(r)
    }
}
function It(e) {
    return void 0 !== e.changeListeners && e.changeListeners.length > 0
}
function Pt(e, t) {
    var r = e.changeListeners || (e.changeListeners = [])
    return (
        r.push(t),
        i(function() {
            var e = r.indexOf(t)
            ;-1 !== e && r.splice(e, 1)
        })
    )
}
function kt(e, t) {
    var r = ie(),
        n = e.changeListeners
    if (n) {
        for (var o = 0, i = (n = n.slice()).length; o < i; o++) n[o](t)
        ae(r)
    }
}
var Nt = {
    get: function(e, t) {
        return t === y
            ? e[y]
            : "length" === t
            ? e[y].getArrayLength()
            : "number" == typeof t
            ? Lt.get.call(e, t)
            : "string" != typeof t || isNaN(t)
            ? Lt.hasOwnProperty(t)
                ? Lt[t]
                : e[t]
            : Lt.get.call(e, parseInt(t))
    },
    set: function(e, t, r) {
        return (
            "length" === t && e[y].setArrayLength(r),
            "number" == typeof t && Lt.set.call(e, t, r),
            "symbol" == typeof t || isNaN(t) ? (e[t] = r) : Lt.set.call(e, parseInt(t), r),
            !0
        )
    },
    preventExtensions: function(e) {
        return n("Observable arrays cannot be frozen"), !1
    }
}
function Vt(e, t, n, o) {
    void 0 === n && (n = "ObservableArray@" + r()), void 0 === o && (o = !1)
    var i,
        a,
        s,
        u = new Bt(n, t, o)
    ;(i = u.values),
        (a = y),
        (s = u),
        Object.defineProperty(i, a, { enumerable: !1, writable: !1, configurable: !0, value: s })
    var c = new Proxy(u.values, Nt)
    if (((u.proxy = c), e && e.length)) {
        var l = be(!0)
        u.spliceWithArray(0, 0, e), ge(l)
    }
    return c
}
var Bt = (function() {
        function t(e, t, n) {
            ;(this.owned = n),
                (this.values = []),
                (this.proxy = void 0),
                (this.lastKnownLength = 0),
                (this.atom = new b(e || "ObservableArray@" + r())),
                (this.enhancer = function(r, n) {
                    return t(r, n, e + "[..]")
                })
        }
        return (
            (t.prototype.dehanceValue = function(e) {
                return void 0 !== this.dehancer ? this.dehancer(e) : e
            }),
            (t.prototype.dehanceValues = function(e) {
                return void 0 !== this.dehancer && e.length > 0 ? e.map(this.dehancer) : e
            }),
            (t.prototype.intercept = function(e) {
                return Rt(this, e)
            }),
            (t.prototype.observe = function(e, t) {
                return (
                    void 0 === t && (t = !1),
                    t &&
                        e({
                            object: this.proxy,
                            type: "splice",
                            index: 0,
                            added: this.values.slice(),
                            addedCount: this.values.length,
                            removed: [],
                            removedCount: 0
                        }),
                    Pt(this, e)
                )
            }),
            (t.prototype.getArrayLength = function() {
                return this.atom.reportObserved(), this.values.length
            }),
            (t.prototype.setArrayLength = function(e) {
                if ("number" != typeof e || e < 0)
                    throw new Error("[mobx.array] Out of range: " + e)
                var t = this.values.length
                if (e !== t)
                    if (e > t) {
                        for (var r = new Array(e - t), n = 0; n < e - t; n++) r[n] = void 0
                        this.spliceWithArray(t, 0, r)
                    } else this.spliceWithArray(e, t - e)
            }),
            (t.prototype.updateArrayLength = function(e, t) {
                if (e !== this.lastKnownLength)
                    throw new Error(
                        "[mobx] Modification exception: the internal structure of an observable array was changed."
                    )
                this.lastKnownLength += t
            }),
            (t.prototype.spliceWithArray = function(t, r, n) {
                var o = this
                te(this.atom)
                var i = this.values.length
                if (
                    (void 0 === t ? (t = 0) : t > i ? (t = i) : t < 0 && (t = Math.max(0, i + t)),
                    (r =
                        1 === arguments.length
                            ? i - t
                            : null == r
                            ? 0
                            : Math.max(0, Math.min(r, i - t))),
                    void 0 === n && (n = e),
                    Ct(this))
                ) {
                    var a = Tt(this, {
                        object: this.proxy,
                        type: "splice",
                        index: t,
                        removedCount: r,
                        added: n
                    })
                    if (!a) return e
                    ;(r = a.removedCount), (n = a.added)
                }
                n =
                    0 === n.length
                        ? n
                        : n.map(function(e) {
                              return o.enhancer(e, void 0)
                          })
                var s = this.spliceItemsIntoValues(t, r, n)
                return (
                    (0 === r && 0 === n.length) || this.notifyArraySplice(t, n, s),
                    this.dehanceValues(s)
                )
            }),
            (t.prototype.spliceItemsIntoValues = function(e, t, r) {
                var n
                if (r.length < 1e4) return (n = this.values).splice.apply(n, _([e, t], r))
                var o = this.values.slice(e, e + t)
                return (
                    (this.values = this.values.slice(0, e).concat(r, this.values.slice(e + t))), o
                )
            }),
            (t.prototype.notifyArrayChildUpdate = function(e, t, r) {
                var n = !this.owned && !1,
                    o = It(this),
                    i =
                        o || n
                            ? {
                                  object: this.proxy,
                                  type: "update",
                                  index: e,
                                  newValue: t,
                                  oldValue: r
                              }
                            : null
                this.atom.reportChanged(), o && kt(this, i)
            }),
            (t.prototype.notifyArraySplice = function(e, t, r) {
                var n = !this.owned && !1,
                    o = It(this),
                    i =
                        o || n
                            ? {
                                  object: this.proxy,
                                  type: "splice",
                                  index: e,
                                  removed: r,
                                  added: t,
                                  removedCount: r.length,
                                  addedCount: t.length
                              }
                            : null
                this.atom.reportChanged(), o && kt(this, i)
            }),
            t
        )
    })(),
    Lt = {
        intercept: function(e) {
            return this[y].intercept(e)
        },
        observe: function(e, t) {
            return void 0 === t && (t = !1), this[y].observe(e, t)
        },
        clear: function() {
            return this.splice(0)
        },
        replace: function(e) {
            var t = this[y]
            return t.spliceWithArray(0, t.values.length, e)
        },
        toJS: function() {
            return this.slice()
        },
        toJSON: function() {
            return this.toJS()
        },
        splice: function(e, t) {
            for (var r = [], n = 2; n < arguments.length; n++) r[n - 2] = arguments[n]
            var o = this[y]
            switch (arguments.length) {
                case 0:
                    return []
                case 1:
                    return o.spliceWithArray(e)
                case 2:
                    return o.spliceWithArray(e, t)
            }
            return o.spliceWithArray(e, t, r)
        },
        spliceWithArray: function(e, t, r) {
            return this[y].spliceWithArray(e, t, r)
        },
        push: function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
            var r = this[y]
            return r.spliceWithArray(r.values.length, 0, e), r.values.length
        },
        pop: function() {
            return this.splice(Math.max(this[y].values.length - 1, 0), 1)[0]
        },
        shift: function() {
            return this.splice(0, 1)[0]
        },
        unshift: function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
            var r = this[y]
            return r.spliceWithArray(0, 0, e), r.values.length
        },
        reverse: function() {
            var e = this.slice()
            return e.reverse.apply(e, arguments)
        },
        sort: function(e) {
            var t = this.slice()
            return t.sort.apply(t, arguments)
        },
        remove: function(e) {
            var t = this[y],
                r = t.dehanceValues(t.values).indexOf(e)
            return r > -1 && (this.splice(r, 1), !0)
        },
        get: function(e) {
            var t = this[y]
            if (t) {
                if (e < t.values.length) return t.atom.reportObserved(), t.dehanceValue(t.values[e])
                console.warn(
                    "[mobx.array] Attempt to read an array index (" +
                        e +
                        ") that is out of bounds (" +
                        t.values.length +
                        "). Please check length first. Out of bound indices will not be tracked by MobX"
                )
            }
        },
        set: function(e, t) {
            var r = this[y],
                n = r.values
            if (e < n.length) {
                te(r.atom)
                var o = n[e]
                if (Ct(r)) {
                    var i = Tt(r, { type: "update", object: r.proxy, index: e, newValue: t })
                    if (!i) return
                    t = i.newValue
                }
                ;(t = r.enhancer(t, o)) !== o && ((n[e] = t), r.notifyArrayChildUpdate(e, t, o))
            } else {
                if (e !== n.length)
                    throw new Error(
                        "[mobx.array] Index out of bounds, " + e + " is larger than " + n.length
                    )
                r.spliceWithArray(e, 0, [t])
            }
        }
    }
;[
    "concat",
    "every",
    "filter",
    "forEach",
    "indexOf",
    "join",
    "lastIndexOf",
    "map",
    "reduce",
    "reduceRight",
    "slice",
    "some",
    "toString",
    "toLocaleString"
].forEach(function(e) {
    Lt[e] = function() {
        var t = this[y]
        t.atom.reportObserved()
        var r = t.dehanceValues(t.values)
        return r[e].apply(r, arguments)
    }
})
var Mt,
    Ut = l("ObservableArrayAdministration", Bt)
function Gt(e) {
    return s(e) && Ut(e[y])
}
var qt,
    zt = {},
    Kt = (function() {
        function e(e, t, n) {
            if (
                (void 0 === t && (t = k),
                void 0 === n && (n = "ObservableMap@" + r()),
                (this.enhancer = t),
                (this.name = n),
                (this[Mt] = zt),
                (this._keysAtom = m(this.name + ".keys()")),
                (this[Symbol.toStringTag] = "Map"),
                "function" != typeof Map)
            )
                throw new Error(
                    "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js"
                )
            ;(this._data = new Map()), (this._hasMap = new Map()), this.merge(e)
        }
        return (
            (e.prototype._has = function(e) {
                return this._data.has(e)
            }),
            (e.prototype.has = function(e) {
                var t = this
                if (!Ce.trackingDerivation) return this._has(e)
                var r = this._hasMap.get(e)
                if (!r) {
                    var n = (r = new me(this._has(e), N, this.name + "." + d(e) + "?", !1))
                    this._hasMap.set(e, n),
                        et(n, function() {
                            return t._hasMap.delete(e)
                        })
                }
                return r.get()
            }),
            (e.prototype.set = function(e, t) {
                var r = this._has(e)
                if (Ct(this)) {
                    var n = Tt(this, {
                        type: r ? "update" : "add",
                        object: this,
                        newValue: t,
                        name: e
                    })
                    if (!n) return this
                    t = n.newValue
                }
                return r ? this._updateValue(e, t) : this._addValue(e, t), this
            }),
            (e.prototype.delete = function(e) {
                var t = this
                if (
                    (te(this._keysAtom), Ct(this)) &&
                    !(n = Tt(this, { type: "delete", object: this, name: e }))
                )
                    return !1
                if (this._has(e)) {
                    var r = It(this),
                        n = r
                            ? {
                                  type: "delete",
                                  object: this,
                                  oldValue: this._data.get(e).value,
                                  name: e
                              }
                            : null
                    return (
                        Ot(function() {
                            t._keysAtom.reportChanged(),
                                t._updateHasMapEntry(e, !1),
                                t._data.get(e).setNewValue(void 0),
                                t._data.delete(e)
                        }),
                        r && kt(this, n),
                        !0
                    )
                }
                return !1
            }),
            (e.prototype._updateHasMapEntry = function(e, t) {
                var r = this._hasMap.get(e)
                r && r.setNewValue(t)
            }),
            (e.prototype._updateValue = function(e, t) {
                var r = this._data.get(e)
                if ((t = r.prepareNewValue(t)) !== Ce.UNCHANGED) {
                    var n = It(this),
                        o = n
                            ? {
                                  type: "update",
                                  object: this,
                                  oldValue: r.value,
                                  name: e,
                                  newValue: t
                              }
                            : null
                    0, r.setNewValue(t), n && kt(this, o)
                }
            }),
            (e.prototype._addValue = function(e, t) {
                var r = this
                te(this._keysAtom),
                    Ot(function() {
                        var n = new me(t, r.enhancer, r.name + "." + d(e), !1)
                        r._data.set(e, n),
                            (t = n.value),
                            r._updateHasMapEntry(e, !0),
                            r._keysAtom.reportChanged()
                    })
                var n = It(this)
                n && kt(this, n ? { type: "add", object: this, name: e, newValue: t } : null)
            }),
            (e.prototype.get = function(e) {
                return this.has(e)
                    ? this.dehanceValue(this._data.get(e).get())
                    : this.dehanceValue(void 0)
            }),
            (e.prototype.dehanceValue = function(e) {
                return void 0 !== this.dehancer ? this.dehancer(e) : e
            }),
            (e.prototype.keys = function() {
                return this._keysAtom.reportObserved(), this._data.keys()
            }),
            (e.prototype.values = function() {
                var e = this,
                    t = this.keys()
                return cr({
                    next: function() {
                        var r = t.next(),
                            n = r.done,
                            o = r.value
                        return { done: n, value: n ? void 0 : e.get(o) }
                    }
                })
            }),
            (e.prototype.entries = function() {
                var e = this,
                    t = this.keys()
                return cr({
                    next: function() {
                        var r = t.next(),
                            n = r.done,
                            o = r.value
                        return { done: n, value: n ? void 0 : [o, e.get(o)] }
                    }
                })
            }),
            (e.prototype[((Mt = y), Symbol.iterator)] = function() {
                return this.entries()
            }),
            (e.prototype.forEach = function(e, t) {
                var r, n
                try {
                    for (var o = S(this), i = o.next(); !i.done; i = o.next()) {
                        var a = A(i.value, 2),
                            s = a[0],
                            u = a[1]
                        e.call(t, u, s, this)
                    }
                } catch (e) {
                    r = { error: e }
                } finally {
                    try {
                        i && !i.done && (n = o.return) && n.call(o)
                    } finally {
                        if (r) throw r.error
                    }
                }
            }),
            (e.prototype.merge = function(e) {
                var t = this
                return (
                    Ht(e) && (e = e.toJS()),
                    Ot(function() {
                        u(e)
                            ? h(e).forEach(function(r) {
                                  return t.set(r, e[r])
                              })
                            : Array.isArray(e)
                            ? e.forEach(function(e) {
                                  var r = A(e, 2),
                                      n = r[0],
                                      o = r[1]
                                  return t.set(n, o)
                              })
                            : f(e)
                            ? (e.constructor !== Map &&
                                  n(
                                      "Cannot initialize from classes that inherit from Map: " +
                                          e.constructor.name
                                  ),
                              e.forEach(function(e, r) {
                                  return t.set(r, e)
                              }))
                            : null != e && n("Cannot initialize map from " + e)
                    }),
                    this
                )
            }),
            (e.prototype.clear = function() {
                var e = this
                Ot(function() {
                    oe(function() {
                        var t, r
                        try {
                            for (var n = S(e.keys()), o = n.next(); !o.done; o = n.next()) {
                                var i = o.value
                                e.delete(i)
                            }
                        } catch (e) {
                            t = { error: e }
                        } finally {
                            try {
                                o && !o.done && (r = n.return) && r.call(n)
                            } finally {
                                if (t) throw t.error
                            }
                        }
                    })
                })
            }),
            (e.prototype.replace = function(e) {
                var t = this
                return (
                    Ot(function() {
                        var r,
                            o,
                            i,
                            a,
                            s = (function(e) {
                                if (f(e) || Ht(e)) return e
                                if (Array.isArray(e)) return new Map(e)
                                if (u(e)) {
                                    var t = new Map()
                                    for (var r in e) t.set(r, e[r])
                                    return t
                                }
                                return n("Cannot convert to map from '" + e + "'")
                            })(e),
                            c = new Map(),
                            l = !1
                        try {
                            for (var p = S(t._data.keys()), h = p.next(); !h.done; h = p.next()) {
                                var d = h.value
                                if (!s.has(d))
                                    if (t.delete(d)) l = !0
                                    else {
                                        var v = t._data.get(d)
                                        c.set(d, v)
                                    }
                            }
                        } catch (e) {
                            r = { error: e }
                        } finally {
                            try {
                                h && !h.done && (o = p.return) && o.call(p)
                            } finally {
                                if (r) throw r.error
                            }
                        }
                        try {
                            for (var y = S(s.entries()), b = y.next(); !b.done; b = y.next()) {
                                var g = A(b.value, 2),
                                    m = ((d = g[0]), (v = g[1]), t._data.has(d))
                                if ((t.set(d, v), t._data.has(d))) {
                                    var w = t._data.get(d)
                                    c.set(d, w), m || (l = !0)
                                }
                            }
                        } catch (e) {
                            i = { error: e }
                        } finally {
                            try {
                                b && !b.done && (a = y.return) && a.call(y)
                            } finally {
                                if (i) throw i.error
                            }
                        }
                        if (!l)
                            if (t._data.size !== c.size) t._keysAtom.reportChanged()
                            else
                                for (
                                    var x = t._data.keys(),
                                        O = c.keys(),
                                        _ = x.next(),
                                        E = O.next();
                                    !_.done;

                                ) {
                                    if (_.value !== E.value) {
                                        t._keysAtom.reportChanged()
                                        break
                                    }
                                    ;(_ = x.next()), (E = O.next())
                                }
                        t._data = c
                    }),
                    this
                )
            }),
            Object.defineProperty(e.prototype, "size", {
                get: function() {
                    return this._keysAtom.reportObserved(), this._data.size
                },
                enumerable: !0,
                configurable: !0
            }),
            (e.prototype.toPOJO = function() {
                var e,
                    t,
                    r = {}
                try {
                    for (var n = S(this), o = n.next(); !o.done; o = n.next()) {
                        var i = A(o.value, 2),
                            a = i[0],
                            s = i[1]
                        r["symbol" == typeof a ? a : d(a)] = s
                    }
                } catch (t) {
                    e = { error: t }
                } finally {
                    try {
                        o && !o.done && (t = n.return) && t.call(n)
                    } finally {
                        if (e) throw e.error
                    }
                }
                return r
            }),
            (e.prototype.toJS = function() {
                return new Map(this)
            }),
            (e.prototype.toJSON = function() {
                return this.toPOJO()
            }),
            (e.prototype.toString = function() {
                var e = this
                return (
                    this.name +
                    "[{ " +
                    Array.from(this.keys())
                        .map(function(t) {
                            return d(t) + ": " + e.get(t)
                        })
                        .join(", ") +
                    " }]"
                )
            }),
            (e.prototype.observe = function(e, t) {
                return Pt(this, e)
            }),
            (e.prototype.intercept = function(e) {
                return Rt(this, e)
            }),
            e
        )
    })(),
    Ht = l("ObservableMap", Kt),
    Wt = {},
    Jt = (function() {
        function e(e, t, n) {
            if (
                (void 0 === t && (t = k),
                void 0 === n && (n = "ObservableSet@" + r()),
                (this.name = n),
                (this[qt] = Wt),
                (this._data = new Set()),
                (this._atom = m(this.name)),
                (this[Symbol.toStringTag] = "Set"),
                "function" != typeof Set)
            )
                throw new Error(
                    "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js"
                )
            ;(this.enhancer = function(e, r) {
                return t(e, r, n)
            }),
                e && this.replace(e)
        }
        return (
            (e.prototype.dehanceValue = function(e) {
                return void 0 !== this.dehancer ? this.dehancer(e) : e
            }),
            (e.prototype.clear = function() {
                var e = this
                Ot(function() {
                    oe(function() {
                        var t, r
                        try {
                            for (var n = S(e._data.values()), o = n.next(); !o.done; o = n.next()) {
                                var i = o.value
                                e.delete(i)
                            }
                        } catch (e) {
                            t = { error: e }
                        } finally {
                            try {
                                o && !o.done && (r = n.return) && r.call(n)
                            } finally {
                                if (t) throw t.error
                            }
                        }
                    })
                })
            }),
            (e.prototype.forEach = function(e, t) {
                var r, n
                try {
                    for (var o = S(this), i = o.next(); !i.done; i = o.next()) {
                        var a = i.value
                        e.call(t, a, a, this)
                    }
                } catch (e) {
                    r = { error: e }
                } finally {
                    try {
                        i && !i.done && (n = o.return) && n.call(o)
                    } finally {
                        if (r) throw r.error
                    }
                }
            }),
            Object.defineProperty(e.prototype, "size", {
                get: function() {
                    return this._atom.reportObserved(), this._data.size
                },
                enumerable: !0,
                configurable: !0
            }),
            (e.prototype.add = function(e) {
                var t = this
                if (
                    (te(this._atom), Ct(this)) &&
                    !(n = Tt(this, { type: "add", object: this, newValue: e }))
                )
                    return this
                if (!this.has(e)) {
                    Ot(function() {
                        t._data.add(t.enhancer(e, void 0)), t._atom.reportChanged()
                    })
                    var r = It(this),
                        n = r ? { type: "add", object: this, newValue: e } : null
                    r && kt(this, n)
                }
                return this
            }),
            (e.prototype.delete = function(e) {
                var t = this
                if (Ct(this) && !(n = Tt(this, { type: "delete", object: this, oldValue: e })))
                    return !1
                if (this.has(e)) {
                    var r = It(this),
                        n = r ? { type: "delete", object: this, oldValue: e } : null
                    return (
                        Ot(function() {
                            t._atom.reportChanged(), t._data.delete(e)
                        }),
                        r && kt(this, n),
                        !0
                    )
                }
                return !1
            }),
            (e.prototype.has = function(e) {
                return this._atom.reportObserved(), this._data.has(this.dehanceValue(e))
            }),
            (e.prototype.entries = function() {
                var e = 0,
                    t = Array.from(this.keys()),
                    r = Array.from(this.values())
                return cr({
                    next: function() {
                        var n = e
                        return (
                            (e += 1),
                            n < r.length ? { value: [t[n], r[n]], done: !1 } : { done: !0 }
                        )
                    }
                })
            }),
            (e.prototype.keys = function() {
                return this.values()
            }),
            (e.prototype.values = function() {
                this._atom.reportObserved()
                var e = this,
                    t = 0,
                    r = Array.from(this._data.values())
                return cr({
                    next: function() {
                        return t < r.length
                            ? { value: e.dehanceValue(r[t++]), done: !1 }
                            : { done: !0 }
                    }
                })
            }),
            (e.prototype.replace = function(e) {
                var t = this
                return (
                    Xt(e) && (e = e.toJS()),
                    Ot(function() {
                        Array.isArray(e)
                            ? (t.clear(),
                              e.forEach(function(e) {
                                  return t.add(e)
                              }))
                            : p(e)
                            ? (t.clear(),
                              e.forEach(function(e) {
                                  return t.add(e)
                              }))
                            : null != e && n("Cannot initialize set from " + e)
                    }),
                    this
                )
            }),
            (e.prototype.observe = function(e, t) {
                return Pt(this, e)
            }),
            (e.prototype.intercept = function(e) {
                return Rt(this, e)
            }),
            (e.prototype.toJS = function() {
                return new Set(this)
            }),
            (e.prototype.toString = function() {
                return this.name + "[ " + Array.from(this).join(", ") + " ]"
            }),
            (e.prototype[((qt = y), Symbol.iterator)] = function() {
                return this.values()
            }),
            e
        )
    })(),
    Xt = l("ObservableSet", Jt),
    Yt = (function() {
        function e(e, t, r, n) {
            void 0 === t && (t = new Map()),
                (this.target = e),
                (this.values = t),
                (this.name = r),
                (this.defaultEnhancer = n),
                (this.keysAtom = new b(r + ".keys"))
        }
        return (
            (e.prototype.read = function(e) {
                return this.values.get(e).get()
            }),
            (e.prototype.write = function(e, t) {
                var r = this.target,
                    n = this.values.get(e)
                if (n instanceof xe) n.set(t)
                else {
                    if (Ct(this)) {
                        if (
                            !(i = Tt(this, {
                                type: "update",
                                object: this.proxy || r,
                                name: e,
                                newValue: t
                            }))
                        )
                            return
                        t = i.newValue
                    }
                    if ((t = n.prepareNewValue(t)) !== Ce.UNCHANGED) {
                        var o = It(this),
                            i = o
                                ? {
                                      type: "update",
                                      object: this.proxy || r,
                                      oldValue: n.value,
                                      name: e,
                                      newValue: t
                                  }
                                : null
                        0, n.setNewValue(t), o && kt(this, i)
                    }
                }
            }),
            (e.prototype.has = function(e) {
                var t = this.pendingKeys || (this.pendingKeys = new Map()),
                    r = t.get(e)
                if (r) return r.get()
                var n = !!this.values.get(e)
                return (r = new me(n, N, this.name + "." + d(e) + "?", !1)), t.set(e, r), r.get()
            }),
            (e.prototype.addObservableProp = function(e, t, r) {
                void 0 === r && (r = this.defaultEnhancer)
                var n = this.target
                if (Ct(this)) {
                    var o = Tt(this, { object: this.proxy || n, name: e, type: "add", newValue: t })
                    if (!o) return
                    t = o.newValue
                }
                var i = new me(t, r, this.name + "." + d(e), !1)
                this.values.set(e, i),
                    (t = i.value),
                    Object.defineProperty(
                        n,
                        e,
                        (function(e) {
                            return (
                                $t[e] ||
                                ($t[e] = {
                                    configurable: !0,
                                    enumerable: !0,
                                    get: function() {
                                        return this[y].read(e)
                                    },
                                    set: function(t) {
                                        this[y].write(e, t)
                                    }
                                })
                            )
                        })(e)
                    ),
                    this.notifyPropertyAddition(e, t)
            }),
            (e.prototype.addComputedProp = function(e, t, r) {
                var n,
                    o,
                    i,
                    a = this.target
                ;(r.name = r.name || this.name + "." + d(t)),
                    this.values.set(t, new xe(r)),
                    (e === a ||
                        ((n = e),
                        (o = t),
                        !(i = Object.getOwnPropertyDescriptor(n, o)) ||
                            (!1 !== i.configurable && !1 !== i.writable))) &&
                        Object.defineProperty(
                            e,
                            t,
                            (function(e) {
                                return (
                                    Qt[e] ||
                                    (Qt[e] = {
                                        configurable: Ce.computedConfigurable,
                                        enumerable: !1,
                                        get: function() {
                                            return Zt(this).read(e)
                                        },
                                        set: function(t) {
                                            Zt(this).write(e, t)
                                        }
                                    })
                                )
                            })(t)
                        )
            }),
            (e.prototype.remove = function(e) {
                if (this.values.has(e)) {
                    var t = this.target
                    if (Ct(this))
                        if (!(a = Tt(this, { object: this.proxy || t, name: e, type: "remove" })))
                            return
                    try {
                        Pe()
                        var r = It(this),
                            n = this.values.get(e),
                            o = n && n.get()
                        if (
                            (n && n.set(void 0),
                            this.keysAtom.reportChanged(),
                            this.values.delete(e),
                            this.pendingKeys)
                        ) {
                            var i = this.pendingKeys.get(e)
                            i && i.set(!1)
                        }
                        delete this.target[e]
                        var a = r
                            ? { type: "remove", object: this.proxy || t, oldValue: o, name: e }
                            : null
                        0, r && kt(this, a)
                    } finally {
                        ke()
                    }
                }
            }),
            (e.prototype.illegalAccess = function(e, t) {
                console.warn(
                    "Property '" +
                        t +
                        "' of '" +
                        e +
                        "' was accessed through the prototype chain. Use 'decorate' instead to declare the prop or access it statically through it's owner"
                )
            }),
            (e.prototype.observe = function(e, t) {
                return Pt(this, e)
            }),
            (e.prototype.intercept = function(e) {
                return Rt(this, e)
            }),
            (e.prototype.notifyPropertyAddition = function(e, t) {
                var r = It(this),
                    n = r
                        ? { type: "add", object: this.proxy || this.target, name: e, newValue: t }
                        : null
                if ((r && kt(this, n), this.pendingKeys)) {
                    var o = this.pendingKeys.get(e)
                    o && o.set(!0)
                }
                this.keysAtom.reportChanged()
            }),
            (e.prototype.getKeys = function() {
                var e, t
                this.keysAtom.reportObserved()
                var r = []
                try {
                    for (var n = S(this.values), o = n.next(); !o.done; o = n.next()) {
                        var i = A(o.value, 2),
                            a = i[0]
                        i[1] instanceof me && r.push(a)
                    }
                } catch (t) {
                    e = { error: t }
                } finally {
                    try {
                        o && !o.done && (t = n.return) && t.call(n)
                    } finally {
                        if (e) throw e.error
                    }
                }
                return r
            }),
            e
        )
    })()
function Ft(e, t, n) {
    if (
        (void 0 === t && (t = ""),
        void 0 === n && (n = k),
        Object.prototype.hasOwnProperty.call(e, y))
    )
        return e[y]
    u(e) || (t = (e.constructor.name || "ObservableObject") + "@" + r()),
        t || (t = "ObservableObject@" + r())
    var o = new Yt(e, new Map(), d(t), n)
    return c(e, y, o), o
}
var $t = Object.create(null),
    Qt = Object.create(null)
function Zt(e) {
    var t = e[y]
    return t || (T(e), e[y])
}
var er = l("ObservableObjectAdministration", Yt)
function tr(e) {
    return !!s(e) && (T(e), er(e[y]))
}
function rr(e, t) {
    if ("object" == typeof e && null !== e) {
        if (Gt(e)) return void 0 !== t && n(!1), e[y].atom
        if (Xt(e)) return e[y]
        if (Ht(e)) {
            var r = e
            return void 0 === t
                ? r._keysAtom
                : ((o = r._data.get(t) || r._hasMap.get(t)) || n(!1), o)
        }
        var o
        if ((T(e), t && !e[y] && e[t], tr(e)))
            return t ? ((o = e[y].values.get(t)) || n(!1), o) : n(!1)
        if (g(e) || Oe(e) || qe(e)) return e
    } else if ("function" == typeof e && qe(e[y])) return e[y]
    return n(!1)
}
function nr(e, t) {
    return (
        e || n("Expecting some object"),
        void 0 !== t
            ? nr(rr(e, t))
            : g(e) || Oe(e) || qe(e)
            ? e
            : Ht(e) || Xt(e)
            ? e
            : (T(e), e[y] ? e[y] : void n(!1))
    )
}
function or(e, t) {
    return (void 0 !== t ? rr(e, t) : tr(e) || Ht(e) || Xt(e) ? nr(e) : rr(e)).name
}
var ir = Object.prototype.toString
function ar(e, t, r) {
    return (
        void 0 === r && (r = -1),
        (function e(t, r, n, o, i) {
            if (t === r) return 0 !== t || 1 / t == 1 / r
            if (null == t || null == r) return !1
            if (t != t) return r != r
            var a = typeof t
            if ("function" !== a && "object" !== a && "object" != typeof r) return !1
            var s = ir.call(t)
            if (s !== ir.call(r)) return !1
            switch (s) {
                case "[object RegExp]":
                case "[object String]":
                    return "" + t == "" + r
                case "[object Number]":
                    return +t != +t ? +r != +r : 0 == +t ? 1 / +t == 1 / r : +t == +r
                case "[object Date]":
                case "[object Boolean]":
                    return +t == +r
                case "[object Symbol]":
                    return (
                        "undefined" != typeof Symbol &&
                        Symbol.valueOf.call(t) === Symbol.valueOf.call(r)
                    )
                case "[object Map]":
                case "[object Set]":
                    n >= 0 && n++
            }
            ;(t = sr(t)), (r = sr(r))
            var u = "[object Array]" === s
            if (!u) {
                if ("object" != typeof t || "object" != typeof r) return !1
                var c = t.constructor,
                    l = r.constructor
                if (
                    c !== l &&
                    !(
                        "function" == typeof c &&
                        c instanceof c &&
                        "function" == typeof l &&
                        l instanceof l
                    ) &&
                    "constructor" in t &&
                    "constructor" in r
                )
                    return !1
            }
            if (0 === n) return !1
            n < 0 && (n = -1)
            i = i || []
            var f = (o = o || []).length
            for (; f--; ) if (o[f] === t) return i[f] === r
            if ((o.push(t), i.push(r), u)) {
                if ((f = t.length) !== r.length) return !1
                for (; f--; ) if (!e(t[f], r[f], n - 1, o, i)) return !1
            } else {
                var p = Object.keys(t),
                    h = void 0
                if (((f = p.length), Object.keys(r).length !== f)) return !1
                for (; f--; ) if (((h = p[f]), !ur(r, h) || !e(t[h], r[h], n - 1, o, i))) return !1
            }
            return o.pop(), i.pop(), !0
        })(e, t, r)
    )
}
function sr(e) {
    return Gt(e)
        ? e.slice()
        : f(e) || Ht(e)
        ? Array.from(e.entries())
        : p(e) || Xt(e)
        ? Array.from(e.entries())
        : e
}
function ur(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}
function cr(e) {
    return (e[Symbol.iterator] = lr), e
}
function lr() {
    return this
}
if ("undefined" == typeof Proxy || "undefined" == typeof Symbol)
    throw new Error(
        "[mobx] MobX 5+ requires Proxy and Symbol objects. If your environment doesn't support Symbol or Proxy objects, please downgrade to MobX 4. For React Native Android, consider upgrading JSCore."
    )
"object" == typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ &&
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({ spy: Ke, extras: { getDebugName: or }, $mobx: y }),
    (exports.$mobx = y),
    (exports.FlowCancellationError = ct),
    (exports.ObservableMap = Kt),
    (exports.ObservableSet = Jt),
    (exports.Reaction = Be),
    (exports._allowStateChanges = function(e, t) {
        var r,
            n = be(e)
        try {
            r = t()
        } finally {
            ge(n)
        }
        return r
    }),
    (exports._allowStateChangesInsideComputed = function(e) {
        var t,
            r = Ce.computationDepth
        Ce.computationDepth = 0
        try {
            t = e()
        } finally {
            Ce.computationDepth = r
        }
        return t
    }),
    (exports._allowStateReadsEnd = ue),
    (exports._allowStateReadsStart = se),
    (exports._endAction = ye),
    (exports._getAdministration = nr),
    (exports._getGlobalState = function() {
        return Ce
    }),
    (exports._interceptReads = function(e, t, r) {
        var o
        if (Ht(e) || Gt(e) || we(e)) o = nr(e)
        else {
            if (!tr(e)) return n(!1)
            if ("string" != typeof t) return n(!1)
            o = nr(e, t)
        }
        return void 0 !== o.dehancer
            ? n(!1)
            : ((o.dehancer = "function" == typeof t ? t : r),
              function() {
                  o.dehancer = void 0
              })
    }),
    (exports._isComputingDerivation = function() {
        return null !== Ce.trackingDerivation
    }),
    (exports._resetGlobalState = function() {
        var e = new Ae()
        for (var t in e) -1 === Se.indexOf(t) && (Ce[t] = e[t])
        Ce.allowStateChanges = !Ce.enforceActions
    }),
    (exports._startAction = ve),
    (exports.action = Xe),
    (exports.autorun = Fe),
    (exports.comparer = w),
    (exports.computed = $),
    (exports.configure = function(e) {
        var t = e.enforceActions,
            r = e.computedRequiresReaction,
            o = e.computedConfigurable,
            i = e.disableErrorBoundaries,
            a = e.reactionScheduler,
            s = e.reactionRequiresObservable,
            u = e.observableRequiresReaction
        if (
            (!0 === e.isolateGlobalState &&
                ((Ce.pendingReactions.length || Ce.inBatch || Ce.isRunningReactions) &&
                    n("isolateGlobalState should be called before MobX is running any reactions"),
                (je = !0),
                De &&
                    (0 == --Ee().__mobxInstanceCount && (Ee().__mobxGlobals = void 0),
                    (Ce = new Ae()))),
            void 0 !== t)
        ) {
            var c = void 0
            switch (t) {
                case !0:
                case "observed":
                    c = !0
                    break
                case !1:
                case "never":
                    c = !1
                    break
                case "strict":
                case "always":
                    c = "strict"
                    break
                default:
                    n(
                        "Invalid value for 'enforceActions': '" +
                            t +
                            "', expected 'never', 'always' or 'observed'"
                    )
            }
            ;(Ce.enforceActions = c), (Ce.allowStateChanges = !0 !== c && "strict" !== c)
        }
        void 0 !== r && (Ce.computedRequiresReaction = !!r),
            void 0 !== s && (Ce.reactionRequiresObservable = !!s),
            void 0 !== u &&
                ((Ce.observableRequiresReaction = !!u),
                (Ce.allowStateReads = !Ce.observableRequiresReaction)),
            void 0 !== o && (Ce.computedConfigurable = !!o),
            void 0 !== i &&
                (!0 === i &&
                    console.warn(
                        "WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled."
                    ),
                (Ce.disableErrorBoundaries = !!i)),
            a && ze(a)
    }),
    (exports.createAtom = m),
    (exports.decorate = function(e, t) {
        var r = "function" == typeof e ? e.prototype : e,
            n = function(e) {
                var n = t[e]
                Array.isArray(n) || (n = [n])
                var o = Object.getOwnPropertyDescriptor(r, e),
                    i = n.reduce(function(t, n) {
                        return n(r, e, t)
                    }, o)
                i && Object.defineProperty(r, e, i)
            }
        for (var o in t) n(o)
        return e
    }),
    (exports.entries = function(e) {
        return tr(e)
            ? vt(e).map(function(t) {
                  return [t, e[t]]
              })
            : Ht(e)
            ? vt(e).map(function(t) {
                  return [t, e.get(t)]
              })
            : Xt(e)
            ? Array.from(e.entries())
            : Gt(e)
            ? e.map(function(e, t) {
                  return [t, e]
              })
            : n(!1)
    }),
    (exports.extendObservable = rt),
    (exports.flow = function(e) {
        1 !== arguments.length && n("Flow expects 1 argument and cannot be used as decorator")
        var t = e.name || "<unnamed flow>"
        return function() {
            var r,
                n = this,
                o = arguments,
                i = ++ut,
                s = Xe(t + " - runid: " + i + " - init", e).apply(n, o),
                u = void 0,
                c = new Promise(function(e, n) {
                    var o = 0
                    function a(e) {
                        var r
                        u = void 0
                        try {
                            r = Xe(t + " - runid: " + i + " - yield " + o++, s.next).call(s, e)
                        } catch (e) {
                            return n(e)
                        }
                        l(r)
                    }
                    function c(e) {
                        var r
                        u = void 0
                        try {
                            r = Xe(t + " - runid: " + i + " - yield " + o++, s.throw).call(s, e)
                        } catch (e) {
                            return n(e)
                        }
                        l(r)
                    }
                    function l(t) {
                        if (!t || "function" != typeof t.then)
                            return t.done ? e(t.value) : (u = Promise.resolve(t.value)).then(a, c)
                        t.then(l, n)
                    }
                    ;(r = n), a(void 0)
                })
            return (
                (c.cancel = Xe(t + " - runid: " + i + " - cancel", function() {
                    try {
                        u && lt(u)
                        var e = s.return(void 0),
                            t = Promise.resolve(e.value)
                        t.then(a, a), lt(t), r(new ct())
                    } catch (e) {
                        r(e)
                    }
                })),
                c
            )
        }
    }),
    (exports.get = function(e, t) {
        if (bt(e, t)) return tr(e) ? e[t] : Ht(e) ? e.get(t) : Gt(e) ? e[t] : n(!1)
    }),
    (exports.getAtom = rr),
    (exports.getDebugName = or),
    (exports.getDependencyTree = it),
    (exports.getObserverTree = function(e, t) {
        return st(rr(e, t))
    }),
    (exports.has = bt),
    (exports.intercept = function(e, t, r) {
        return "function" == typeof r
            ? (function(e, t, r) {
                  return nr(e, t).intercept(r)
              })(e, t, r)
            : (function(e, t) {
                  return nr(e).intercept(t)
              })(e, t)
    }),
    (exports.isAction = function(e) {
        return "function" == typeof e && !0 === e.isMobxAction
    }),
    (exports.isArrayLike = function(e) {
        return Array.isArray(e) || Gt(e)
    }),
    (exports.isBoxedObservable = we),
    (exports.isComputed = pt),
    (exports.isComputedProp = function(e, t) {
        return "string" != typeof t ? n(!1) : ft(e, t)
    }),
    (exports.isFlowCancellationError = function(e) {
        return e instanceof ct
    }),
    (exports.isObservable = dt),
    (exports.isObservableArray = Gt),
    (exports.isObservableMap = Ht),
    (exports.isObservableObject = tr),
    (exports.isObservableProp = function(e, t) {
        return "string" != typeof t ? n(!1) : ht(e, t)
    }),
    (exports.isObservableSet = Xt),
    (exports.keys = vt),
    (exports.observable = H),
    (exports.observe = function(e, t, r, n) {
        return "function" == typeof r
            ? (function(e, t, r, n) {
                  return nr(e, t).observe(r, n)
              })(e, t, r, n)
            : (function(e, t, r) {
                  return nr(e).observe(t, r)
              })(e, t, r)
    }),
    (exports.onBecomeObserved = Ze),
    (exports.onBecomeUnobserved = et),
    (exports.onReactionError = function(e) {
        return (
            Ce.globalReactionErrorHandlers.push(e),
            function() {
                var t = Ce.globalReactionErrorHandlers.indexOf(e)
                t >= 0 && Ce.globalReactionErrorHandlers.splice(t, 1)
            }
        )
    }),
    (exports.reaction = function(e, n, o) {
        void 0 === o && (o = t)
        var i,
            a,
            s,
            u = o.name || "Reaction@" + r(),
            c = Xe(
                u,
                o.onError
                    ? ((i = o.onError),
                      (a = n),
                      function() {
                          try {
                              return a.apply(this, arguments)
                          } catch (e) {
                              i.call(this, e)
                          }
                      })
                    : n
            ),
            l = !o.scheduler && !o.delay,
            f = Qe(o),
            p = !0,
            h = !1,
            d = o.compareStructural ? w.structural : o.equals || w.default,
            v = new Be(
                u,
                function() {
                    p || l ? y() : h || ((h = !0), f(y))
                },
                o.onError,
                o.requiresObservable
            )
        function y() {
            if (((h = !1), !v.isDisposed)) {
                var t = !1
                v.track(function() {
                    var r = e(v)
                    ;(t = p || !d(s, r)), (s = r)
                }),
                    p && o.fireImmediately && c(s, v),
                    p || !0 !== t || c(s, v),
                    p && (p = !1)
            }
        }
        return v.schedule(), v.getDisposer()
    }),
    (exports.remove = function(e, t) {
        if (tr(e)) e[y].remove(t)
        else if (Ht(e)) e.delete(t)
        else if (Xt(e)) e.delete(t)
        else {
            if (!Gt(e)) return n(!1)
            "number" != typeof t && (t = parseInt(t, 10)),
                o(t >= 0, "Not a valid index: '" + t + "'"),
                e.splice(t, 1)
        }
    }),
    (exports.runInAction = function(e, t) {
        return "string" == typeof e || e.name, de(0, "function" == typeof e ? e : t, this, void 0)
    }),
    (exports.set = yt),
    (exports.spy = Ke),
    (exports.toJS = function(e, t) {
        var r
        return (
            "boolean" == typeof t && (t = { detectCycles: t }),
            t || (t = gt),
            (t.detectCycles =
                void 0 === t.detectCycles ? !0 === t.recurseEverything : !0 === t.detectCycles),
            t.detectCycles && (r = new Map()),
            (function e(t, r, n) {
                if (!r.recurseEverything && !dt(t)) return t
                if ("object" != typeof t) return t
                if (null === t) return null
                if (t instanceof Date) return t
                if (we(t)) return e(t.get(), r, n)
                if ((dt(t) && vt(t), !0 === r.detectCycles && null !== t && n.has(t)))
                    return n.get(t)
                if (Gt(t) || Array.isArray(t)) {
                    var o = mt(n, t, [], r),
                        i = t.map(function(t) {
                            return e(t, r, n)
                        })
                    o.length = i.length
                    for (var a = 0, s = i.length; a < s; a++) o[a] = i[a]
                    return o
                }
                if (Xt(t) || Object.getPrototypeOf(t) === Set.prototype) {
                    if (!1 === r.exportMapsAsObjects) {
                        var u = mt(n, t, new Set(), r)
                        return (
                            t.forEach(function(t) {
                                u.add(e(t, r, n))
                            }),
                            u
                        )
                    }
                    var c = mt(n, t, [], r)
                    return (
                        t.forEach(function(t) {
                            c.push(e(t, r, n))
                        }),
                        c
                    )
                }
                if (Ht(t) || Object.getPrototypeOf(t) === Map.prototype) {
                    if (!1 === r.exportMapsAsObjects) {
                        var l = mt(n, t, new Map(), r)
                        return (
                            t.forEach(function(t, o) {
                                l.set(o, e(t, r, n))
                            }),
                            l
                        )
                    }
                    var f = mt(n, t, {}, r)
                    return (
                        t.forEach(function(t, o) {
                            f[o] = e(t, r, n)
                        }),
                        f
                    )
                }
                var p = mt(n, t, {}, r)
                return (
                    h(t).forEach(function(o) {
                        p[o] = e(t[o], r, n)
                    }),
                    p
                )
            })(e, t, r)
        )
    }),
    (exports.trace = wt),
    (exports.transaction = Ot),
    (exports.untracked = oe),
    (exports.values = function(e) {
        return tr(e)
            ? vt(e).map(function(t) {
                  return e[t]
              })
            : Ht(e)
            ? vt(e).map(function(t) {
                  return e.get(t)
              })
            : Xt(e)
            ? Array.from(e.values())
            : Gt(e)
            ? e.slice()
            : n(!1)
    }),
    (exports.when = function(e, t, r) {
        return 1 === arguments.length || (t && "object" == typeof t) ? At(e, t) : St(e, t, r || {})
    })
