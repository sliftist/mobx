!(function(e, t) {
    "object" == typeof exports && "undefined" != typeof module
        ? t(exports)
        : "function" == typeof define && define.amd
        ? define(["exports"], t)
        : t(((e = e || self).mobx = {}))
})(this, function(e) {
    "use strict"
    var t = []
    Object.freeze(t)
    var n = {}
    function r() {
        return ++Re.mobxGuid
    }
    function o(e) {
        throw (i(!1, e), "X")
    }
    function i(e, t) {
        if (!e)
            throw new Error(
                "[mobx] " +
                    (t ||
                        "An invariant failed, however the error is obfuscated because this is a production build.")
            )
    }
    function a(e) {
        var t = !1
        return function() {
            if (!t) return (t = !0), e.apply(this, arguments)
        }
    }
    Object.freeze(n)
    var s = function() {}
    function u(e) {
        return null !== e && "object" == typeof e
    }
    function c(e) {
        if (null === e || "object" != typeof e) return !1
        var t = Object.getPrototypeOf(e)
        return t === Object.prototype || null === t
    }
    function l(e, t, n) {
        Object.defineProperty(e, t, { enumerable: !1, writable: !0, configurable: !0, value: n })
    }
    function f(e, t) {
        var n = "isMobX" + e
        return (
            (t.prototype[n] = !0),
            function(e) {
                return u(e) && !0 === e[n]
            }
        )
    }
    function h(e) {
        return e instanceof Map
    }
    function p(e) {
        return e instanceof Set
    }
    function d(e) {
        var t = new Set()
        for (var n in e) t.add(n)
        return (
            Object.getOwnPropertySymbols(e).forEach(function(n) {
                Object.getOwnPropertyDescriptor(e, n).enumerable && t.add(n)
            }),
            Array.from(t)
        )
    }
    function v(e) {
        return e && e.toString ? e.toString() : new String(e).toString()
    }
    function y(e) {
        return null === e ? null : "object" == typeof e ? "" + e : e
    }
    var b = Symbol("mobx administration"),
        g = (function() {
            function t(t) {
                void 0 === t && (t = "Atom@" + r()),
                    (this.name = t),
                    (this.isPendingUnobservation = !1),
                    (this.isBeingObserved = !1),
                    (this.observers = new Set()),
                    (this.diffValue = 0),
                    (this.lastAccessedBy = 0),
                    (this.lowestObserverState = e.IDerivationState.NOT_TRACKING)
            }
            return (
                (t.prototype.onBecomeObserved = function() {
                    this.onBecomeObservedListeners &&
                        this.onBecomeObservedListeners.forEach(function(e) {
                            return e()
                        })
                }),
                (t.prototype.onBecomeUnobserved = function() {
                    this.onBecomeUnobservedListeners &&
                        this.onBecomeUnobservedListeners.forEach(function(e) {
                            return e()
                        })
                }),
                (t.prototype.reportObserved = function() {
                    return Ve(this)
                }),
                (t.prototype.reportChanged = function() {
                    Pe(),
                        (function(t) {
                            if (t.lowestObserverState === e.IDerivationState.STALE) return
                            ;(t.lowestObserverState = e.IDerivationState.STALE),
                                t.observers.forEach(function(n) {
                                    n.dependenciesState === e.IDerivationState.UP_TO_DATE &&
                                        (n.isTracing !== Y.NONE && Be(n, t), n.onBecomeStale()),
                                        (n.dependenciesState = e.IDerivationState.STALE)
                                })
                        })(this),
                        Re.queueReportChangedEndBatchAsMicrotask
                            ? Promise.resolve().then(function() {
                                  Ne()
                              })
                            : Ne()
                }),
                (t.prototype.toString = function() {
                    return this.name
                }),
                t
            )
        })(),
        m = f("Atom", g)
    function w(e, t, n) {
        void 0 === t && (t = s), void 0 === n && (n = s)
        var r = new g(e)
        return t !== s && Ze(r, t), n !== s && et(r, n), r
    }
    var O = {
            identity: function(e, t) {
                return e === t
            },
            structural: function(e, t) {
                return sn(e, t)
            },
            default: function(e, t) {
                return Object.is(e, t)
            },
            shallow: function(e, t) {
                return sn(e, t, 1)
            }
        },
        S = function(e, t) {
            return (S =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                    function(e, t) {
                        e.__proto__ = t
                    }) ||
                function(e, t) {
                    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
                })(e, t)
        }
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */ var A = function() {
        return (A =
            Object.assign ||
            function(e) {
                for (var t, n = 1, r = arguments.length; n < r; n++)
                    for (var o in (t = arguments[n]))
                        Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o])
                return e
            }).apply(this, arguments)
    }
    function _(e) {
        var t = "function" == typeof Symbol && e[Symbol.iterator],
            n = 0
        return t
            ? t.call(e)
            : {
                  next: function() {
                      return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e }
                  }
              }
    }
    function E(e, t) {
        var n = "function" == typeof Symbol && e[Symbol.iterator]
        if (!n) return e
        var r,
            o,
            i = n.call(e),
            a = []
        try {
            for (; (void 0 === t || t-- > 0) && !(r = i.next()).done; ) a.push(r.value)
        } catch (e) {
            o = { error: e }
        } finally {
            try {
                r && !r.done && (n = i.return) && n.call(i)
            } finally {
                if (o) throw o.error
            }
        }
        return a
    }
    function x() {
        for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(E(arguments[t]))
        return e
    }
    var D = Symbol("mobx did run lazy initializers"),
        j = Symbol("mobx pending decorators"),
        C = {},
        R = {}
    function T(e, t) {
        var n = t ? C : R
        return (
            n[e] ||
            (n[e] = {
                configurable: !0,
                enumerable: t,
                get: function() {
                    return I(this), this[e]
                },
                set: function(t) {
                    I(this), (this[e] = t)
                }
            })
        )
    }
    function I(e) {
        var t, n
        if (!0 !== e[D]) {
            var r = e[j]
            if (r) {
                l(e, D, !0)
                var o = x(Object.getOwnPropertySymbols(r), Object.keys(r))
                try {
                    for (var i = _(o), a = i.next(); !a.done; a = i.next()) {
                        var s = r[a.value]
                        s.propertyCreator(
                            e,
                            s.prop,
                            s.descriptor,
                            s.decoratorTarget,
                            s.decoratorArguments
                        )
                    }
                } catch (e) {
                    t = { error: e }
                } finally {
                    try {
                        a && !a.done && (n = i.return) && n.call(i)
                    } finally {
                        if (t) throw t.error
                    }
                }
            }
        }
    }
    function k(e, n) {
        return function() {
            var r,
                o = function(t, o, i, a) {
                    if (!0 === a) return n(t, o, i, t, r), null
                    if (!Object.prototype.hasOwnProperty.call(t, j)) {
                        var s = t[j]
                        l(t, j, A({}, s))
                    }
                    return (
                        (t[j][o] = {
                            prop: o,
                            propertyCreator: n,
                            descriptor: i,
                            decoratorTarget: t,
                            decoratorArguments: r
                        }),
                        T(o, e)
                    )
                }
            return P(arguments)
                ? ((r = t), o.apply(null, arguments))
                : ((r = Array.prototype.slice.call(arguments)), o)
        }
    }
    function P(e) {
        return (
            ((2 === e.length || 3 === e.length) &&
                ("string" == typeof e[1] || "symbol" == typeof e[1])) ||
            (4 === e.length && !0 === e[3])
        )
    }
    function N(e, t, n) {
        return dt(e)
            ? e
            : Array.isArray(e)
            ? W.array(e, { name: n })
            : c(e)
            ? W.object(e, void 0, { name: n })
            : h(e)
            ? W.map(e, { name: n })
            : p(e)
            ? W.set(e, { name: n })
            : e
    }
    function V(e) {
        return e
    }
    function B(e) {
        i(e)
        var t = k(!0, function(t, n, r, o, i) {
                var a = r ? (r.initializer ? r.initializer.call(t) : r.value) : void 0
                Ft(t).addObservableProp(n, a, e)
            }),
            n = ("undefined" != typeof process && process.env, t)
        return (n.enhancer = e), n
    }
    var L = { deep: !0, name: void 0, defaultDecorator: void 0, proxy: !0 }
    function M(e) {
        return null == e ? L : "string" == typeof e ? { name: e, deep: !0, proxy: !0 } : e
    }
    Object.freeze(L)
    var U = B(N),
        G = B(function(e, t, n) {
            return null == e
                ? e
                : tn(e) || Gt(e) || Ht(e) || Xt(e)
                ? e
                : Array.isArray(e)
                ? W.array(e, { name: n, deep: !1 })
                : c(e)
                ? W.object(e, void 0, { name: n, deep: !1 })
                : h(e)
                ? W.map(e, { name: n, deep: !1 })
                : p(e)
                ? W.set(e, { name: n, deep: !1 })
                : o(!1)
        }),
        q = B(V),
        z = B(function(e, t, n) {
            return sn(e, t) ? t : e
        })
    function K(e) {
        return e.defaultDecorator ? e.defaultDecorator.enhancer : !1 === e.deep ? V : N
    }
    var H = {
            box: function(e, t) {
                arguments.length > 2 && J("box")
                var n = M(t)
                return new we(e, K(n), n.name, !0, n.equals)
            },
            array: function(e, t) {
                arguments.length > 2 && J("array")
                var n = M(t)
                return Vt(e, K(n), n.name)
            },
            map: function(e, t) {
                arguments.length > 2 && J("map")
                var n = M(t)
                return new Kt(e, K(n), n.name)
            },
            set: function(e, t) {
                arguments.length > 2 && J("set")
                var n = M(t)
                return new Jt(e, K(n), n.name)
            },
            object: function(e, t, n) {
                "string" == typeof arguments[1] && J("object")
                var r = M(n)
                if (!1 === r.proxy) return nt({}, e, t, r)
                var o = rt(r),
                    i = nt({}, void 0, void 0, r),
                    a = jt(i)
                return ot(a, e, t, o), a
            },
            ref: q,
            shallow: G,
            deep: U,
            struct: z
        },
        W = function(e, t, n) {
            if ("string" == typeof arguments[1] || "symbol" == typeof arguments[1])
                return U.apply(null, arguments)
            if (dt(e)) return e
            var r = c(e)
                ? W.object(e, t, n)
                : Array.isArray(e)
                ? W.array(e, t)
                : h(e)
                ? W.map(e, t)
                : p(e)
                ? W.set(e, t)
                : e
            if (r !== e) return r
            o(!1)
        }
    function J(e) {
        o(
            "Expected one or two arguments to observable." +
                e +
                ". Did you accidentally try to use observable." +
                e +
                " as decorator?"
        )
    }
    Object.keys(H).forEach(function(e) {
        return (W[e] = H[e])
    })
    var X,
        Y,
        F = k(!1, function(e, t, n, r, o) {
            var i = n.get,
                a = n.set,
                s = o[0] || {}
            Ft(e).addComputedProp(e, t, A({ get: i, set: a, context: e }, s))
        }),
        $ = F({ equals: O.structural }),
        Q = function(e, t, n) {
            if ("string" == typeof t) return F.apply(null, arguments)
            if (null !== e && "object" == typeof e && 1 === arguments.length)
                return F.apply(null, arguments)
            var r = "object" == typeof t ? t : {}
            return (
                (r.get = e),
                (r.set = "function" == typeof t ? t : r.set),
                (r.name = r.name || e.name || ""),
                new Se(r)
            )
        }
    ;(Q.struct = $),
        ((X = e.IDerivationState || (e.IDerivationState = {}))[(X.NOT_TRACKING = -1)] =
            "NOT_TRACKING"),
        (X[(X.UP_TO_DATE = 0)] = "UP_TO_DATE"),
        (X[(X.POSSIBLY_STALE = 1)] = "POSSIBLY_STALE"),
        (X[(X.STALE = 2)] = "STALE"),
        (function(e) {
            ;(e[(e.NONE = 0)] = "NONE"), (e[(e.LOG = 1)] = "LOG"), (e[(e.BREAK = 2)] = "BREAK")
        })(Y || (Y = {}))
    var Z = function(e) {
        this.cause = e
    }
    function ee(e) {
        return e instanceof Z
    }
    function te(t) {
        switch (t.dependenciesState) {
            case e.IDerivationState.UP_TO_DATE:
                return !1
            case e.IDerivationState.NOT_TRACKING:
            case e.IDerivationState.STALE:
                return !0
            case e.IDerivationState.POSSIBLY_STALE:
                for (var n = ue(!0), r = ae(), o = t.observing, i = o.length, a = 0; a < i; a++) {
                    var s = o[a]
                    if (Ae(s)) {
                        if (Re.disableErrorBoundaries) s.get()
                        else
                            try {
                                s.get()
                            } catch (e) {
                                return se(r), ce(n), !0
                            }
                        if (t.dependenciesState === e.IDerivationState.STALE)
                            return se(r), ce(n), !0
                    }
                }
                return le(t), se(r), ce(n), !1
        }
    }
    function ne(e) {
        var t = e.observers.size > 0
        Re.computationDepth > 0 && t && o(!1),
            Re.allowStateChanges || (!t && "strict" !== Re.enforceActions) || o(!1)
    }
    function re(t, n, r) {
        var o = ue(!0)
        le(t),
            (t.newObserving = new Array(t.observing.length + 100)),
            (t.unboundDepsCount = 0),
            (t.runId = ++Re.runId)
        var i,
            a = Re.trackingDerivation
        if (((Re.trackingDerivation = t), !0 === Re.disableErrorBoundaries)) i = n.call(r)
        else
            try {
                i = n.call(r)
            } catch (e) {
                i = new Z(e)
            }
        return (
            (Re.trackingDerivation = a),
            (function(t) {
                for (
                    var n = t.observing,
                        r = (t.observing = t.newObserving),
                        o = e.IDerivationState.UP_TO_DATE,
                        i = 0,
                        a = t.unboundDepsCount,
                        s = 0;
                    s < a;
                    s++
                ) {
                    0 === (u = r[s]).diffValue && ((u.diffValue = 1), i !== s && (r[i] = u), i++),
                        u.dependenciesState > o && (o = u.dependenciesState)
                }
                ;(r.length = i), (t.newObserving = null), (a = n.length)
                for (; a--; ) {
                    0 === (u = n[a]).diffValue && Ie(u, t), (u.diffValue = 0)
                }
                for (; i--; ) {
                    var u
                    1 === (u = r[i]).diffValue && ((u.diffValue = 0), Te(u, t))
                }
                o !== e.IDerivationState.UP_TO_DATE &&
                    ((t.dependenciesState = o), t.onBecomeStale())
            })(t),
            ce(o),
            i
        )
    }
    function oe(t) {
        var n = t.observing
        t.observing = []
        for (var r = n.length; r--; ) Ie(n[r], t)
        t.dependenciesState = e.IDerivationState.NOT_TRACKING
    }
    function ie(e) {
        var t = ae()
        try {
            return e()
        } finally {
            se(t)
        }
    }
    function ae() {
        var e = Re.trackingDerivation
        return (Re.trackingDerivation = null), e
    }
    function se(e) {
        Re.trackingDerivation = e
    }
    function ue(e) {
        var t = Re.allowStateReads
        return (Re.allowStateReads = e), t
    }
    function ce(e) {
        Re.allowStateReads = e
    }
    function le(t) {
        if (t.dependenciesState !== e.IDerivationState.UP_TO_DATE) {
            t.dependenciesState = e.IDerivationState.UP_TO_DATE
            for (var n = t.observing, r = n.length; r--; )
                n[r].lowestObserverState = e.IDerivationState.UP_TO_DATE
        }
    }
    var fe = 0,
        he = 1,
        pe = Object.getOwnPropertyDescriptor(function() {}, "name")
    pe && pe.configurable
    function de(e, t, n) {
        var r = function() {
            return ve(e, t, n || this, arguments)
        }
        return (r.isMobxAction = !0), r
    }
    function ve(e, t, n, r) {
        var o = ye()
        try {
            return t.apply(n, r)
        } catch (e) {
            throw ((o.error = e), e)
        } finally {
            be(o)
        }
    }
    function ye(e, t, n) {
        var r = ae()
        Pe()
        var o = {
            prevDerivation: r,
            prevAllowStateChanges: ge(!0),
            prevAllowStateReads: ue(!0),
            notifySpy: !1,
            startTime: 0,
            actionId: he++,
            parentActionId: fe
        }
        return (fe = o.actionId), o
    }
    function be(e) {
        fe !== e.actionId && o("invalid action stack. did you forget to finish an action?"),
            (fe = e.parentActionId),
            void 0 !== e.error && (Re.suppressReactionErrors = !0),
            me(e.prevAllowStateChanges),
            ce(e.prevAllowStateReads),
            Ne(),
            se(e.prevDerivation),
            e.notifySpy,
            (Re.suppressReactionErrors = !1)
    }
    function ge(e) {
        var t = Re.allowStateChanges
        return (Re.allowStateChanges = e), t
    }
    function me(e) {
        Re.allowStateChanges = e
    }
    var we = (function(e) {
            function t(t, n, o, i, a) {
                void 0 === o && (o = "ObservableValue@" + r()),
                    void 0 === i && (i = !0),
                    void 0 === a && (a = O.default)
                var s = e.call(this, o) || this
                return (
                    (s.enhancer = n),
                    (s.name = o),
                    (s.equals = a),
                    (s.hasUnreportedChange = !1),
                    (s.value = n(t, void 0, o)),
                    s
                )
            }
            return (
                (function(e, t) {
                    function n() {
                        this.constructor = e
                    }
                    S(e, t),
                        (e.prototype =
                            null === t ? Object.create(t) : ((n.prototype = t.prototype), new n()))
                })(t, e),
                (t.prototype.dehanceValue = function(e) {
                    return void 0 !== this.dehancer ? this.dehancer(e) : e
                }),
                (t.prototype.set = function(e) {
                    this.value
                    if ((e = this.prepareNewValue(e)) !== Re.UNCHANGED) {
                        0, this.setNewValue(e)
                    }
                }),
                (t.prototype.prepareNewValue = function(e) {
                    if ((ne(this), Ct(this))) {
                        var t = Tt(this, { object: this, type: "update", newValue: e })
                        if (!t) return Re.UNCHANGED
                        e = t.newValue
                    }
                    return (
                        (e = this.enhancer(e, this.value, this.name)),
                        this.equals(this.value, e) ? Re.UNCHANGED : e
                    )
                }),
                (t.prototype.setNewValue = function(e) {
                    var t = this.value
                    ;(this.value = e),
                        this.reportChanged(),
                        It(this) &&
                            Pt(this, { type: "update", object: this, newValue: e, oldValue: t })
                }),
                (t.prototype.get = function() {
                    return this.reportObserved(), this.dehanceValue(this.value)
                }),
                (t.prototype.intercept = function(e) {
                    return Rt(this, e)
                }),
                (t.prototype.observe = function(e, t) {
                    return (
                        t &&
                            e({
                                object: this,
                                type: "update",
                                newValue: this.value,
                                oldValue: void 0
                            }),
                        kt(this, e)
                    )
                }),
                (t.prototype.toJSON = function() {
                    return this.get()
                }),
                (t.prototype.toString = function() {
                    return this.name + "[" + this.value + "]"
                }),
                (t.prototype.valueOf = function() {
                    return y(this.get())
                }),
                (t.prototype[Symbol.toPrimitive] = function() {
                    return this.valueOf()
                }),
                t
            )
        })(g),
        Oe = f("ObservableValue", we),
        Se = (function() {
            function t(t) {
                ;(this.dependenciesState = e.IDerivationState.NOT_TRACKING),
                    (this.observing = []),
                    (this.newObserving = null),
                    (this.isBeingObserved = !1),
                    (this.isPendingUnobservation = !1),
                    (this.observers = new Set()),
                    (this.diffValue = 0),
                    (this.runId = 0),
                    (this.lastAccessedBy = 0),
                    (this.lowestObserverState = e.IDerivationState.UP_TO_DATE),
                    (this.unboundDepsCount = 0),
                    (this.__mapid = "#" + r()),
                    (this.value = new Z(null)),
                    (this.isComputing = !1),
                    (this.isRunningSetter = !1),
                    (this.isTracing = Y.NONE),
                    i(t.get, "missing option for computed: get"),
                    (this.derivation = t.get),
                    (this.name = t.name || "ComputedValue@" + r()),
                    t.set && (this.setter = de(this.name + "-setter", t.set)),
                    (this.equals =
                        t.equals || (t.compareStructural || t.struct ? O.structural : O.default)),
                    (this.scope = t.context),
                    (this.requiresReaction = !!t.requiresReaction),
                    (this.keepAlive = !!t.keepAlive)
            }
            return (
                (t.prototype.onBecomeStale = function() {
                    !(function(t) {
                        if (t.lowestObserverState !== e.IDerivationState.UP_TO_DATE) return
                        ;(t.lowestObserverState = e.IDerivationState.POSSIBLY_STALE),
                            t.observers.forEach(function(n) {
                                n.dependenciesState === e.IDerivationState.UP_TO_DATE &&
                                    ((n.dependenciesState = e.IDerivationState.POSSIBLY_STALE),
                                    n.isTracing !== Y.NONE && Be(n, t),
                                    n.onBecomeStale())
                            })
                    })(this)
                }),
                (t.prototype.onBecomeObserved = function() {
                    this.onBecomeObservedListeners &&
                        this.onBecomeObservedListeners.forEach(function(e) {
                            return e()
                        })
                }),
                (t.prototype.onBecomeUnobserved = function() {
                    this.onBecomeUnobservedListeners &&
                        this.onBecomeUnobservedListeners.forEach(function(e) {
                            return e()
                        })
                }),
                (t.prototype.get = function() {
                    this.isComputing &&
                        o("Cycle detected in computation " + this.name + ": " + this.derivation),
                        0 !== Re.inBatch || 0 !== this.observers.size || this.keepAlive
                            ? (Ve(this),
                              te(this) &&
                                  this.trackAndCompute() &&
                                  (function(t) {
                                      if (t.lowestObserverState === e.IDerivationState.STALE) return
                                      ;(t.lowestObserverState = e.IDerivationState.STALE),
                                          t.observers.forEach(function(n) {
                                              n.dependenciesState ===
                                              e.IDerivationState.POSSIBLY_STALE
                                                  ? (n.dependenciesState = e.IDerivationState.STALE)
                                                  : n.dependenciesState ===
                                                        e.IDerivationState.UP_TO_DATE &&
                                                    (t.lowestObserverState =
                                                        e.IDerivationState.UP_TO_DATE)
                                          })
                                  })(this))
                            : te(this) &&
                              (this.warnAboutUntrackedRead(),
                              Pe(),
                              (this.value = this.computeValue(!1)),
                              Ne())
                    var t = this.value
                    if (ee(t)) throw t.cause
                    return t
                }),
                (t.prototype.peek = function() {
                    var e = this.computeValue(!1)
                    if (ee(e)) throw e.cause
                    return e
                }),
                (t.prototype.set = function(e) {
                    if (this.setter) {
                        i(
                            !this.isRunningSetter,
                            "The setter of computed value '" +
                                this.name +
                                "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?"
                        ),
                            (this.isRunningSetter = !0)
                        try {
                            this.setter.call(this.scope, e)
                        } finally {
                            this.isRunningSetter = !1
                        }
                    } else i(!1, !1)
                }),
                (t.prototype.trackAndCompute = function() {
                    var t = this.value,
                        n = this.dependenciesState === e.IDerivationState.NOT_TRACKING,
                        r = this.computeValue(!0),
                        o = n || ee(t) || ee(r) || !this.equals(t, r)
                    return o && (this.value = r), o
                }),
                (t.prototype.computeValue = function(e) {
                    var t
                    if (((this.isComputing = !0), Re.computationDepth++, e))
                        t = re(this, this.derivation, this.scope)
                    else if (!0 === Re.disableErrorBoundaries) t = this.derivation.call(this.scope)
                    else
                        try {
                            t = this.derivation.call(this.scope)
                        } catch (e) {
                            t = new Z(e)
                        }
                    return Re.computationDepth--, (this.isComputing = !1), t
                }),
                (t.prototype.suspend = function() {
                    this.keepAlive || (oe(this), (this.value = void 0))
                }),
                (t.prototype.observe = function(e, t) {
                    var n = this,
                        r = !0,
                        o = void 0
                    return Fe(function() {
                        var i = n.get()
                        if (!r || t) {
                            var a = ae()
                            e({ type: "update", object: n, newValue: i, oldValue: o }), se(a)
                        }
                        ;(r = !1), (o = i)
                    })
                }),
                (t.prototype.warnAboutUntrackedRead = function() {}),
                (t.prototype.toJSON = function() {
                    return this.get()
                }),
                (t.prototype.toString = function() {
                    return this.name + "[" + this.derivation.toString() + "]"
                }),
                (t.prototype.valueOf = function() {
                    return y(this.get())
                }),
                (t.prototype[Symbol.toPrimitive] = function() {
                    return this.valueOf()
                }),
                t
            )
        })(),
        Ae = f("ComputedValue", Se),
        _e = [
            "mobxGuid",
            "spyListeners",
            "enforceActions",
            "computedRequiresReaction",
            "reactionRequiresObservable",
            "observableRequiresReaction",
            "allowStateReads",
            "disableErrorBoundaries",
            "runId",
            "UNCHANGED"
        ],
        Ee = function() {
            ;(this.version = 5),
                (this.UNCHANGED = {}),
                (this.trackingDerivation = null),
                (this.computationDepth = 0),
                (this.runId = 0),
                (this.mobxGuid = 0),
                (this.inBatch = 0),
                (this.pendingUnobservations = []),
                (this.pendingReactions = []),
                (this.isRunningReactions = !1),
                (this.allowStateChanges = !0),
                (this.allowStateReads = !0),
                (this.enforceActions = !1),
                (this.spyListeners = []),
                (this.globalReactionErrorHandlers = []),
                (this.computedRequiresReaction = !1),
                (this.reactionRequiresObservable = !1),
                (this.observableRequiresReaction = !1),
                (this.computedConfigurable = !1),
                (this.disableErrorBoundaries = !1),
                (this.suppressReactionErrors = !1),
                (this.queueReportChangedEndBatchAsMicrotask = !1)
        },
        xe = {}
    function De() {
        return "undefined" != typeof window
            ? window
            : "undefined" != typeof global
            ? global
            : "undefined" != typeof self
            ? self
            : xe
    }
    var je = !0,
        Ce = !1,
        Re = (function() {
            var e = De()
            return (
                e.__mobxInstanceCount > 0 && !e.__mobxGlobals && (je = !1),
                e.__mobxGlobals && e.__mobxGlobals.version !== new Ee().version && (je = !1),
                je
                    ? e.__mobxGlobals
                        ? ((e.__mobxInstanceCount += 1),
                          e.__mobxGlobals.UNCHANGED || (e.__mobxGlobals.UNCHANGED = {}),
                          e.__mobxGlobals)
                        : ((e.__mobxInstanceCount = 1), (e.__mobxGlobals = new Ee()))
                    : (setTimeout(function() {
                          Ce ||
                              o(
                                  "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`"
                              )
                      }, 1),
                      new Ee())
            )
        })()
    function Te(e, t) {
        e.observers.add(t),
            e.lowestObserverState > t.dependenciesState &&
                (e.lowestObserverState = t.dependenciesState)
    }
    function Ie(e, t) {
        e.observers.delete(t), 0 === e.observers.size && ke(e)
    }
    function ke(e) {
        !1 === e.isPendingUnobservation &&
            ((e.isPendingUnobservation = !0), Re.pendingUnobservations.push(e))
    }
    function Pe() {
        Re.inBatch++
    }
    function Ne() {
        if (0 == --Re.inBatch) {
            Ue()
            for (var e = Re.pendingUnobservations, t = 0; t < e.length; t++) {
                var n = e[t]
                ;(n.isPendingUnobservation = !1),
                    0 === n.observers.size &&
                        (n.isBeingObserved && ((n.isBeingObserved = !1), n.onBecomeUnobserved()),
                        n instanceof Se && n.suspend())
            }
            Re.pendingUnobservations = []
        }
    }
    function Ve(e) {
        var t = Re.trackingDerivation
        return null !== t
            ? (t.runId !== e.lastAccessedBy &&
                  ((e.lastAccessedBy = t.runId),
                  (t.newObserving[t.unboundDepsCount++] = e),
                  e.isBeingObserved || ((e.isBeingObserved = !0), e.onBecomeObserved())),
              !0)
            : (0 === e.observers.size && Re.inBatch > 0 && ke(e), !1)
    }
    function Be(e, t) {
        if (
            (console.log(
                "[mobx.trace] '" + e.name + "' is invalidated due to a change in: '" + t.name + "'"
            ),
            e.isTracing === Y.BREAK)
        ) {
            var n = []
            !(function e(t, n, r) {
                if (n.length >= 1e3) return void n.push("(and many more)")
                n.push("" + new Array(r).join("\t") + t.name),
                    t.dependencies &&
                        t.dependencies.forEach(function(t) {
                            return e(t, n, r + 1)
                        })
            })(it(e), n, 1),
                new Function(
                    "debugger;\n/*\nTracing '" +
                        e.name +
                        "'\n\nYou are entering this break point because derivation '" +
                        e.name +
                        "' is being traced and '" +
                        t.name +
                        "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" +
                        (e instanceof Se ? e.derivation.toString().replace(/[*]\//g, "/") : "") +
                        "\n\nThe dependencies for this derivation are:\n\n" +
                        n.join("\n") +
                        "\n*/\n    "
                )()
        }
    }
    var Le = (function() {
        function t(t, n, o, i) {
            void 0 === t && (t = "Reaction@" + r()),
                void 0 === i && (i = !1),
                (this.name = t),
                (this.onInvalidate = n),
                (this.errorHandler = o),
                (this.requiresObservable = i),
                (this.observing = []),
                (this.newObserving = []),
                (this.dependenciesState = e.IDerivationState.NOT_TRACKING),
                (this.diffValue = 0),
                (this.runId = 0),
                (this.unboundDepsCount = 0),
                (this.__mapid = "#" + r()),
                (this.isDisposed = !1),
                (this._isScheduled = !1),
                (this._isTrackPending = !1),
                (this._isRunning = !1),
                (this.isTracing = Y.NONE)
        }
        return (
            (t.prototype.onBecomeStale = function() {
                this.schedule()
            }),
            (t.prototype.schedule = function() {
                this._isScheduled ||
                    ((this._isScheduled = !0), Re.pendingReactions.push(this), Ue())
            }),
            (t.prototype.isScheduled = function() {
                return this._isScheduled
            }),
            (t.prototype.runReaction = function() {
                if (!this.isDisposed) {
                    if ((Pe(), (this._isScheduled = !1), te(this))) {
                        this._isTrackPending = !0
                        try {
                            this.onInvalidate(), this._isTrackPending
                        } catch (e) {
                            this.reportExceptionInDerivation(e)
                        }
                    }
                    Ne()
                }
            }),
            (t.prototype.track = function(e) {
                if (!this.isDisposed) {
                    Pe(), (this._isRunning = !0)
                    var t = re(this, e, void 0)
                    ;(this._isRunning = !1),
                        (this._isTrackPending = !1),
                        this.isDisposed && oe(this),
                        ee(t) && this.reportExceptionInDerivation(t.cause),
                        Ne()
                }
            }),
            (t.prototype.reportExceptionInDerivation = function(e) {
                var t = this
                if (this.errorHandler) this.errorHandler(e, this)
                else {
                    if (Re.disableErrorBoundaries) throw e
                    var n =
                        "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" +
                        this +
                        "'"
                    Re.suppressReactionErrors
                        ? console.warn(
                              "[mobx] (error in reaction '" +
                                  this.name +
                                  "' suppressed, fix error of causing action below)"
                          )
                        : console.error(n, e),
                        Re.globalReactionErrorHandlers.forEach(function(n) {
                            return n(e, t)
                        })
                }
            }),
            (t.prototype.dispose = function() {
                this.isDisposed ||
                    ((this.isDisposed = !0), this._isRunning || (Pe(), oe(this), Ne()))
            }),
            (t.prototype.getDisposer = function() {
                var e = this.dispose.bind(this)
                return (e[b] = this), e
            }),
            (t.prototype.toString = function() {
                return "Reaction[" + this.name + "]"
            }),
            (t.prototype.trace = function(e) {
                void 0 === e && (e = !1), wt(this, e)
            }),
            t
        )
    })()
    var Me = function(e) {
        return e()
    }
    function Ue() {
        Re.inBatch > 0 || Re.isRunningReactions || Me(Ge)
    }
    function Ge() {
        Re.isRunningReactions = !0
        for (var e = Re.pendingReactions, t = 0; e.length > 0; ) {
            100 == ++t &&
                (console.error(
                    "Reaction doesn't converge to a stable state after 100 iterations. Probably there is a cycle in the reactive function: " +
                        e[0]
                ),
                e.splice(0))
            for (var n = e.splice(0), r = 0, o = n.length; r < o; r++) n[r].runReaction()
        }
        Re.isRunningReactions = !1
    }
    var qe = f("Reaction", Le)
    function ze(e) {
        var t = Me
        Me = function(n) {
            return e(function() {
                return t(n)
            })
        }
    }
    function Ke(e) {
        return console.warn("[mobx.spy] Is a no-op in production builds"), function() {}
    }
    function He() {
        o(!1)
    }
    function We(e) {
        return function(t, n, r) {
            if (r) {
                if (r.value)
                    return { value: de(e, r.value), enumerable: !1, configurable: !0, writable: !0 }
                var o = r.initializer
                return {
                    enumerable: !1,
                    configurable: !0,
                    writable: !0,
                    initializer: function() {
                        return de(e, o.call(this))
                    }
                }
            }
            return Je(e).apply(this, arguments)
        }
    }
    function Je(e) {
        return function(t, n, r) {
            Object.defineProperty(t, n, {
                configurable: !0,
                enumerable: !1,
                get: function() {},
                set: function(t) {
                    l(this, n, Xe(e, t))
                }
            })
        }
    }
    var Xe = function(e, t, n, r) {
        return 1 === arguments.length && "function" == typeof e
            ? de(e.name || "<unnamed action>", e)
            : 2 === arguments.length && "function" == typeof t
            ? de(e, t)
            : 1 === arguments.length && "string" == typeof e
            ? We(e)
            : !0 !== r
            ? We(t).apply(null, arguments)
            : void l(e, t, de(e.name || t, n.value, this))
    }
    function Ye(e, t, n) {
        l(e, t, de(t, n.bind(e)))
    }
    function Fe(e, t) {
        void 0 === t && (t = n)
        var o,
            i = (t && t.name) || e.name || "Autorun@" + r()
        if (!t.scheduler && !t.delay)
            o = new Le(
                i,
                function() {
                    this.track(u)
                },
                t.onError,
                t.requiresObservable
            )
        else {
            var a = Qe(t),
                s = !1
            o = new Le(
                i,
                function() {
                    s ||
                        ((s = !0),
                        a(function() {
                            ;(s = !1), o.isDisposed || o.track(u)
                        }))
                },
                t.onError,
                t.requiresObservable
            )
        }
        function u() {
            e(o)
        }
        return o.schedule(), o.getDisposer()
    }
    Xe.bound = function(e, t, n, r) {
        return !0 === r
            ? (Ye(e, t, n.value), null)
            : n
            ? {
                  configurable: !0,
                  enumerable: !1,
                  get: function() {
                      return Ye(this, t, n.value || n.initializer.call(this)), this[t]
                  },
                  set: He
              }
            : {
                  enumerable: !1,
                  configurable: !0,
                  set: function(e) {
                      Ye(this, t, e)
                  },
                  get: function() {}
              }
    }
    var $e = function(e) {
        return e()
    }
    function Qe(e) {
        return e.scheduler
            ? e.scheduler
            : e.delay
            ? function(t) {
                  return setTimeout(t, e.delay)
              }
            : $e
    }
    function Ze(e, t, n) {
        return tt("onBecomeObserved", e, t, n)
    }
    function et(e, t, n) {
        return tt("onBecomeUnobserved", e, t, n)
    }
    function tt(e, t, n, r) {
        var i = "function" == typeof r ? nn(t, n) : nn(t),
            a = "function" == typeof r ? r : n,
            s = e + "Listeners"
        return (
            i[s] ? i[s].add(a) : (i[s] = new Set([a])),
            "function" != typeof i[e]
                ? o(!1)
                : function() {
                      var e = i[s]
                      e && (e.delete(a), 0 === e.size && delete i[s])
                  }
        )
    }
    function nt(e, t, n, r) {
        var o = rt((r = M(r)))
        return I(e), Ft(e, r.name, o.enhancer), t && ot(e, t, n, o), e
    }
    function rt(e) {
        return e.defaultDecorator || (!1 === e.deep ? q : U)
    }
    function ot(e, t, n, r) {
        var o, i
        Pe()
        try {
            var a = d(t)
            try {
                for (var s = _(a), u = s.next(); !u.done; u = s.next()) {
                    var c = u.value,
                        l = Object.getOwnPropertyDescriptor(t, c)
                    0
                    var f = n && c in n ? n[c] : l.get ? F : r
                    0
                    var h = f(e, c, l, !0)
                    h && Object.defineProperty(e, c, h)
                }
            } catch (e) {
                o = { error: e }
            } finally {
                try {
                    u && !u.done && (i = s.return) && i.call(s)
                } finally {
                    if (o) throw o.error
                }
            }
        } finally {
            Ne()
        }
    }
    function it(e, t) {
        return at(nn(e, t))
    }
    function at(e) {
        var t,
            n,
            r = { name: e.name }
        return (
            e.observing &&
                e.observing.length > 0 &&
                (r.dependencies = ((t = e.observing),
                (n = []),
                t.forEach(function(e) {
                    ;-1 === n.indexOf(e) && n.push(e)
                }),
                n).map(at)),
            r
        )
    }
    function st(e) {
        var t = { name: e.name }
        return (
            (function(e) {
                return e.observers && e.observers.size > 0
            })(e) &&
                (t.observers = Array.from(
                    (function(e) {
                        return e.observers
                    })(e)
                ).map(st)),
            t
        )
    }
    var ut = 0
    function ct() {
        this.message = "FLOW_CANCELLED"
    }
    function lt(e) {
        "function" == typeof e.cancel && e.cancel()
    }
    function ft(e, t) {
        if (null == e) return !1
        if (void 0 !== t) {
            if (!1 === tn(e)) return !1
            if (!e[b].values.has(t)) return !1
            var n = nn(e, t)
            return Ae(n)
        }
        return Ae(e)
    }
    function ht(e) {
        return arguments.length > 1 ? o(!1) : ft(e)
    }
    function pt(e, t) {
        return (
            null != e &&
            (void 0 !== t
                ? !!tn(e) && e[b].values.has(t)
                : tn(e) || !!e[b] || m(e) || qe(e) || Ae(e))
        )
    }
    function dt(e) {
        return 1 !== arguments.length && o(!1), pt(e)
    }
    function vt(e) {
        return tn(e)
            ? e[b].getKeys()
            : Ht(e)
            ? Array.from(e.keys())
            : Xt(e)
            ? Array.from(e.keys())
            : Gt(e)
            ? e.map(function(e, t) {
                  return t
              })
            : o(!1)
    }
    function yt(e, t, n) {
        if (2 !== arguments.length || Xt(e))
            if (tn(e)) {
                var r = e[b],
                    a = r.values.get(t)
                a ? r.write(t, n) : r.addObservableProp(t, n, r.defaultEnhancer)
            } else if (Ht(e)) e.set(t, n)
            else if (Xt(e)) e.add(t)
            else {
                if (!Gt(e)) return o(!1)
                "number" != typeof t && (t = parseInt(t, 10)),
                    i(t >= 0, "Not a valid index: '" + t + "'"),
                    Pe(),
                    t >= e.length && (e.length = t + 1),
                    (e[t] = n),
                    Ne()
            }
        else {
            Pe()
            var s = t
            try {
                for (var u in s) yt(e, u, s[u])
            } finally {
                Ne()
            }
        }
    }
    function bt(e, t) {
        return tn(e)
            ? rn(e).has(t)
            : Ht(e)
            ? e.has(t)
            : Xt(e)
            ? e.has(t)
            : Gt(e)
            ? t >= 0 && t < e.length
            : o(!1)
    }
    ct.prototype = Object.create(Error.prototype)
    var gt = { detectCycles: !0, exportMapsAsObjects: !0, recurseEverything: !1 }
    function mt(e, t, n, r) {
        return r.detectCycles && e.set(t, n), n
    }
    function wt() {
        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
        var n = !1
        "boolean" == typeof e[e.length - 1] && (n = e.pop())
        var r = Ot(e)
        if (!r) return o(!1)
        r.isTracing === Y.NONE && console.log("[mobx.trace] '" + r.name + "' tracing enabled"),
            (r.isTracing = n ? Y.BREAK : Y.LOG)
    }
    function Ot(e) {
        switch (e.length) {
            case 0:
                return Re.trackingDerivation
            case 1:
                return nn(e[0])
            case 2:
                return nn(e[0], e[1])
        }
    }
    function St(e, t) {
        void 0 === t && (t = void 0), Pe()
        try {
            return e.apply(t)
        } finally {
            Ne()
        }
    }
    function At(e, t, n) {
        var o
        "number" == typeof n.timeout &&
            (o = setTimeout(function() {
                if (!a[b].isDisposed) {
                    a()
                    var e = new Error("WHEN_TIMEOUT")
                    if (!n.onError) throw e
                    n.onError(e)
                }
            }, n.timeout)),
            (n.name = n.name || "When@" + r())
        var i = de(n.name + "-effect", t),
            a = Fe(function(t) {
                e() && (t.dispose(), o && clearTimeout(o), i())
            }, n)
        return a
    }
    function _t(e, t) {
        var n,
            r = new Promise(function(r, o) {
                var i = At(e, r, A(A({}, t), { onError: o }))
                n = function() {
                    i(), o("WHEN_CANCELLED")
                }
            })
        return (r.cancel = n), r
    }
    function Et(e) {
        return e[b]
    }
    function xt(e) {
        return "string" == typeof e || "number" == typeof e || "symbol" == typeof e
    }
    var Dt = {
        has: function(e, t) {
            if (t === b || "constructor" === t || t === D) return !0
            var n = Et(e)
            return xt(t) ? n.has(t) : t in e
        },
        get: function(e, t) {
            if (t === b || "constructor" === t || t === D) return e[t]
            var n = Et(e),
                r = n.values.get(t)
            if (r instanceof g) {
                var o = r.get()
                return void 0 === o && n.has(t), o
            }
            return xt(t) && n.has(t), e[t]
        },
        set: function(e, t, n) {
            return !!xt(t) && (yt(e, t, n), !0)
        },
        deleteProperty: function(e, t) {
            return !!xt(t) && (Et(e).remove(t), !0)
        },
        ownKeys: function(e) {
            return Et(e).keysAtom.reportObserved(), Reflect.ownKeys(e)
        },
        preventExtensions: function(e) {
            return o("Dynamic observable objects cannot be frozen"), !1
        }
    }
    function jt(e) {
        var t = new Proxy(e, Dt)
        return (e[b].proxy = t), t
    }
    function Ct(e) {
        return void 0 !== e.interceptors && e.interceptors.length > 0
    }
    function Rt(e, t) {
        var n = e.interceptors || (e.interceptors = [])
        return (
            n.push(t),
            a(function() {
                var e = n.indexOf(t)
                ;-1 !== e && n.splice(e, 1)
            })
        )
    }
    function Tt(e, t) {
        var n = ae()
        try {
            for (
                var r = x(e.interceptors || []), o = 0, a = r.length;
                o < a &&
                (i(
                    !(t = r[o](t)) || t.type,
                    "Intercept handlers should return nothing or a change object"
                ),
                t);
                o++
            );
            return t
        } finally {
            se(n)
        }
    }
    function It(e) {
        return void 0 !== e.changeListeners && e.changeListeners.length > 0
    }
    function kt(e, t) {
        var n = e.changeListeners || (e.changeListeners = [])
        return (
            n.push(t),
            a(function() {
                var e = n.indexOf(t)
                ;-1 !== e && n.splice(e, 1)
            })
        )
    }
    function Pt(e, t) {
        var n = ae(),
            r = e.changeListeners
        if (r) {
            for (var o = 0, i = (r = r.slice()).length; o < i; o++) r[o](t)
            se(n)
        }
    }
    var Nt = {
        get: function(e, t) {
            return t === b
                ? e[b]
                : "length" === t
                ? e[b].getArrayLength()
                : "number" == typeof t
                ? Lt.get.call(e, t)
                : "string" != typeof t || isNaN(t)
                ? Lt.hasOwnProperty(t)
                    ? Lt[t]
                    : e[t]
                : Lt.get.call(e, parseInt(t))
        },
        set: function(e, t, n) {
            return (
                "length" === t && e[b].setArrayLength(n),
                "number" == typeof t && Lt.set.call(e, t, n),
                "symbol" == typeof t || isNaN(t) ? (e[t] = n) : Lt.set.call(e, parseInt(t), n),
                !0
            )
        },
        preventExtensions: function(e) {
            return o("Observable arrays cannot be frozen"), !1
        }
    }
    function Vt(e, t, n, o) {
        void 0 === n && (n = "ObservableArray@" + r()), void 0 === o && (o = !1)
        var i,
            a,
            s,
            u = new Bt(n, t, o)
        ;(i = u.values),
            (a = b),
            (s = u),
            Object.defineProperty(i, a, {
                enumerable: !1,
                writable: !1,
                configurable: !0,
                value: s
            })
        var c = new Proxy(u.values, Nt)
        if (((u.proxy = c), e && e.length)) {
            var l = ge(!0)
            u.spliceWithArray(0, 0, e), me(l)
        }
        return c
    }
    var Bt = (function() {
            function e(e, t, n) {
                ;(this.owned = n),
                    (this.values = []),
                    (this.proxy = void 0),
                    (this.lastKnownLength = 0),
                    (this.atom = new g(e || "ObservableArray@" + r())),
                    (this.enhancer = function(n, r) {
                        return t(n, r, e + "[..]")
                    })
            }
            return (
                (e.prototype.dehanceValue = function(e) {
                    return void 0 !== this.dehancer ? this.dehancer(e) : e
                }),
                (e.prototype.dehanceValues = function(e) {
                    return void 0 !== this.dehancer && e.length > 0 ? e.map(this.dehancer) : e
                }),
                (e.prototype.intercept = function(e) {
                    return Rt(this, e)
                }),
                (e.prototype.observe = function(e, t) {
                    return (
                        void 0 === t && (t = !1),
                        t &&
                            e({
                                object: this.proxy,
                                type: "splice",
                                index: 0,
                                added: this.values.slice(),
                                addedCount: this.values.length,
                                removed: [],
                                removedCount: 0
                            }),
                        kt(this, e)
                    )
                }),
                (e.prototype.getArrayLength = function() {
                    return this.atom.reportObserved(), this.values.length
                }),
                (e.prototype.setArrayLength = function(e) {
                    if ("number" != typeof e || e < 0)
                        throw new Error("[mobx.array] Out of range: " + e)
                    var t = this.values.length
                    if (e !== t)
                        if (e > t) {
                            for (var n = new Array(e - t), r = 0; r < e - t; r++) n[r] = void 0
                            this.spliceWithArray(t, 0, n)
                        } else this.spliceWithArray(e, t - e)
                }),
                (e.prototype.updateArrayLength = function(e, t) {
                    if (e !== this.lastKnownLength)
                        throw new Error(
                            "[mobx] Modification exception: the internal structure of an observable array was changed."
                        )
                    this.lastKnownLength += t
                }),
                (e.prototype.spliceWithArray = function(e, n, r) {
                    var o = this
                    ne(this.atom)
                    var i = this.values.length
                    if (
                        (void 0 === e
                            ? (e = 0)
                            : e > i
                            ? (e = i)
                            : e < 0 && (e = Math.max(0, i + e)),
                        (n =
                            1 === arguments.length
                                ? i - e
                                : null == n
                                ? 0
                                : Math.max(0, Math.min(n, i - e))),
                        void 0 === r && (r = t),
                        Ct(this))
                    ) {
                        var a = Tt(this, {
                            object: this.proxy,
                            type: "splice",
                            index: e,
                            removedCount: n,
                            added: r
                        })
                        if (!a) return t
                        ;(n = a.removedCount), (r = a.added)
                    }
                    r =
                        0 === r.length
                            ? r
                            : r.map(function(e) {
                                  return o.enhancer(e, void 0)
                              })
                    var s = this.spliceItemsIntoValues(e, n, r)
                    return (
                        (0 === n && 0 === r.length) || this.notifyArraySplice(e, r, s),
                        this.dehanceValues(s)
                    )
                }),
                (e.prototype.spliceItemsIntoValues = function(e, t, n) {
                    var r
                    if (n.length < 1e4) return (r = this.values).splice.apply(r, x([e, t], n))
                    var o = this.values.slice(e, e + t)
                    return (
                        (this.values = this.values.slice(0, e).concat(n, this.values.slice(e + t))),
                        o
                    )
                }),
                (e.prototype.notifyArrayChildUpdate = function(e, t, n) {
                    var r = !this.owned && !1,
                        o = It(this),
                        i =
                            o || r
                                ? {
                                      object: this.proxy,
                                      type: "update",
                                      index: e,
                                      newValue: t,
                                      oldValue: n
                                  }
                                : null
                    this.atom.reportChanged(), o && Pt(this, i)
                }),
                (e.prototype.notifyArraySplice = function(e, t, n) {
                    var r = !this.owned && !1,
                        o = It(this),
                        i =
                            o || r
                                ? {
                                      object: this.proxy,
                                      type: "splice",
                                      index: e,
                                      removed: n,
                                      added: t,
                                      removedCount: n.length,
                                      addedCount: t.length
                                  }
                                : null
                    this.atom.reportChanged(), o && Pt(this, i)
                }),
                e
            )
        })(),
        Lt = {
            intercept: function(e) {
                return this[b].intercept(e)
            },
            observe: function(e, t) {
                return void 0 === t && (t = !1), this[b].observe(e, t)
            },
            clear: function() {
                return this.splice(0)
            },
            replace: function(e) {
                var t = this[b]
                return t.spliceWithArray(0, t.values.length, e)
            },
            toJS: function() {
                return this.slice()
            },
            toJSON: function() {
                return this.toJS()
            },
            splice: function(e, t) {
                for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r]
                var o = this[b]
                switch (arguments.length) {
                    case 0:
                        return []
                    case 1:
                        return o.spliceWithArray(e)
                    case 2:
                        return o.spliceWithArray(e, t)
                }
                return o.spliceWithArray(e, t, n)
            },
            spliceWithArray: function(e, t, n) {
                return this[b].spliceWithArray(e, t, n)
            },
            push: function() {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
                var n = this[b]
                return n.spliceWithArray(n.values.length, 0, e), n.values.length
            },
            pop: function() {
                return this.splice(Math.max(this[b].values.length - 1, 0), 1)[0]
            },
            shift: function() {
                return this.splice(0, 1)[0]
            },
            unshift: function() {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
                var n = this[b]
                return n.spliceWithArray(0, 0, e), n.values.length
            },
            reverse: function() {
                var e = this.slice()
                return e.reverse.apply(e, arguments)
            },
            sort: function(e) {
                var t = this.slice()
                return t.sort.apply(t, arguments)
            },
            remove: function(e) {
                var t = this[b],
                    n = t.dehanceValues(t.values).indexOf(e)
                return n > -1 && (this.splice(n, 1), !0)
            },
            get: function(e) {
                var t = this[b]
                if (t) {
                    if (e < t.values.length)
                        return t.atom.reportObserved(), t.dehanceValue(t.values[e])
                    console.warn(
                        "[mobx.array] Attempt to read an array index (" +
                            e +
                            ") that is out of bounds (" +
                            t.values.length +
                            "). Please check length first. Out of bound indices will not be tracked by MobX"
                    )
                }
            },
            set: function(e, t) {
                var n = this[b],
                    r = n.values
                if (e < r.length) {
                    ne(n.atom)
                    var o = r[e]
                    if (Ct(n)) {
                        var i = Tt(n, { type: "update", object: n.proxy, index: e, newValue: t })
                        if (!i) return
                        t = i.newValue
                    }
                    ;(t = n.enhancer(t, o)) !== o && ((r[e] = t), n.notifyArrayChildUpdate(e, t, o))
                } else {
                    if (e !== r.length)
                        throw new Error(
                            "[mobx.array] Index out of bounds, " + e + " is larger than " + r.length
                        )
                    n.spliceWithArray(e, 0, [t])
                }
            }
        }
    ;[
        "concat",
        "every",
        "filter",
        "forEach",
        "indexOf",
        "join",
        "lastIndexOf",
        "map",
        "reduce",
        "reduceRight",
        "slice",
        "some",
        "toString",
        "toLocaleString"
    ].forEach(function(e) {
        Lt[e] = function() {
            var t = this[b]
            t.atom.reportObserved()
            var n = t.dehanceValues(t.values)
            return n[e].apply(n, arguments)
        }
    })
    var Mt,
        Ut = f("ObservableArrayAdministration", Bt)
    function Gt(e) {
        return u(e) && Ut(e[b])
    }
    var qt,
        zt = {},
        Kt = (function() {
            function e(e, t, n) {
                if (
                    (void 0 === t && (t = N),
                    void 0 === n && (n = "ObservableMap@" + r()),
                    (this.enhancer = t),
                    (this.name = n),
                    (this[Mt] = zt),
                    (this._keysAtom = w(this.name + ".keys()")),
                    (this[Symbol.toStringTag] = "Map"),
                    "function" != typeof Map)
                )
                    throw new Error(
                        "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js"
                    )
                ;(this._data = new Map()), (this._hasMap = new Map()), this.merge(e)
            }
            return (
                (e.prototype._has = function(e) {
                    return this._data.has(e)
                }),
                (e.prototype.has = function(e) {
                    var t = this
                    if (!Re.trackingDerivation) return this._has(e)
                    var n = this._hasMap.get(e)
                    if (!n) {
                        var r = (n = new we(this._has(e), V, this.name + "." + v(e) + "?", !1))
                        this._hasMap.set(e, r),
                            et(r, function() {
                                return t._hasMap.delete(e)
                            })
                    }
                    return n.get()
                }),
                (e.prototype.set = function(e, t) {
                    var n = this._has(e)
                    if (Ct(this)) {
                        var r = Tt(this, {
                            type: n ? "update" : "add",
                            object: this,
                            newValue: t,
                            name: e
                        })
                        if (!r) return this
                        t = r.newValue
                    }
                    return n ? this._updateValue(e, t) : this._addValue(e, t), this
                }),
                (e.prototype.delete = function(e) {
                    var t = this
                    if (
                        (ne(this._keysAtom), Ct(this)) &&
                        !(r = Tt(this, { type: "delete", object: this, name: e }))
                    )
                        return !1
                    if (this._has(e)) {
                        var n = It(this),
                            r = n
                                ? {
                                      type: "delete",
                                      object: this,
                                      oldValue: this._data.get(e).value,
                                      name: e
                                  }
                                : null
                        return (
                            St(function() {
                                t._keysAtom.reportChanged(),
                                    t._updateHasMapEntry(e, !1),
                                    t._data.get(e).setNewValue(void 0),
                                    t._data.delete(e)
                            }),
                            n && Pt(this, r),
                            !0
                        )
                    }
                    return !1
                }),
                (e.prototype._updateHasMapEntry = function(e, t) {
                    var n = this._hasMap.get(e)
                    n && n.setNewValue(t)
                }),
                (e.prototype._updateValue = function(e, t) {
                    var n = this._data.get(e)
                    if ((t = n.prepareNewValue(t)) !== Re.UNCHANGED) {
                        var r = It(this),
                            o = r
                                ? {
                                      type: "update",
                                      object: this,
                                      oldValue: n.value,
                                      name: e,
                                      newValue: t
                                  }
                                : null
                        0, n.setNewValue(t), r && Pt(this, o)
                    }
                }),
                (e.prototype._addValue = function(e, t) {
                    var n = this
                    ne(this._keysAtom),
                        St(function() {
                            var r = new we(t, n.enhancer, n.name + "." + v(e), !1)
                            n._data.set(e, r),
                                (t = r.value),
                                n._updateHasMapEntry(e, !0),
                                n._keysAtom.reportChanged()
                        })
                    var r = It(this)
                    r && Pt(this, r ? { type: "add", object: this, name: e, newValue: t } : null)
                }),
                (e.prototype.get = function(e) {
                    return this.has(e)
                        ? this.dehanceValue(this._data.get(e).get())
                        : this.dehanceValue(void 0)
                }),
                (e.prototype.dehanceValue = function(e) {
                    return void 0 !== this.dehancer ? this.dehancer(e) : e
                }),
                (e.prototype.keys = function() {
                    return this._keysAtom.reportObserved(), this._data.keys()
                }),
                (e.prototype.values = function() {
                    var e = this,
                        t = this.keys()
                    return ln({
                        next: function() {
                            var n = t.next(),
                                r = n.done,
                                o = n.value
                            return { done: r, value: r ? void 0 : e.get(o) }
                        }
                    })
                }),
                (e.prototype.entries = function() {
                    var e = this,
                        t = this.keys()
                    return ln({
                        next: function() {
                            var n = t.next(),
                                r = n.done,
                                o = n.value
                            return { done: r, value: r ? void 0 : [o, e.get(o)] }
                        }
                    })
                }),
                (e.prototype[((Mt = b), Symbol.iterator)] = function() {
                    return this.entries()
                }),
                (e.prototype.forEach = function(e, t) {
                    var n, r
                    try {
                        for (var o = _(this), i = o.next(); !i.done; i = o.next()) {
                            var a = E(i.value, 2),
                                s = a[0],
                                u = a[1]
                            e.call(t, u, s, this)
                        }
                    } catch (e) {
                        n = { error: e }
                    } finally {
                        try {
                            i && !i.done && (r = o.return) && r.call(o)
                        } finally {
                            if (n) throw n.error
                        }
                    }
                }),
                (e.prototype.merge = function(e) {
                    var t = this
                    return (
                        Ht(e) && (e = e.toJS()),
                        St(function() {
                            c(e)
                                ? d(e).forEach(function(n) {
                                      return t.set(n, e[n])
                                  })
                                : Array.isArray(e)
                                ? e.forEach(function(e) {
                                      var n = E(e, 2),
                                          r = n[0],
                                          o = n[1]
                                      return t.set(r, o)
                                  })
                                : h(e)
                                ? (e.constructor !== Map &&
                                      o(
                                          "Cannot initialize from classes that inherit from Map: " +
                                              e.constructor.name
                                      ),
                                  e.forEach(function(e, n) {
                                      return t.set(n, e)
                                  }))
                                : null != e && o("Cannot initialize map from " + e)
                        }),
                        this
                    )
                }),
                (e.prototype.clear = function() {
                    var e = this
                    St(function() {
                        ie(function() {
                            var t, n
                            try {
                                for (var r = _(e.keys()), o = r.next(); !o.done; o = r.next()) {
                                    var i = o.value
                                    e.delete(i)
                                }
                            } catch (e) {
                                t = { error: e }
                            } finally {
                                try {
                                    o && !o.done && (n = r.return) && n.call(r)
                                } finally {
                                    if (t) throw t.error
                                }
                            }
                        })
                    })
                }),
                (e.prototype.replace = function(e) {
                    var t = this
                    return (
                        St(function() {
                            var n,
                                r,
                                i,
                                a,
                                s = (function(e) {
                                    if (h(e) || Ht(e)) return e
                                    if (Array.isArray(e)) return new Map(e)
                                    if (c(e)) {
                                        var t = new Map()
                                        for (var n in e) t.set(n, e[n])
                                        return t
                                    }
                                    return o("Cannot convert to map from '" + e + "'")
                                })(e),
                                u = new Map(),
                                l = !1
                            try {
                                for (
                                    var f = _(t._data.keys()), p = f.next();
                                    !p.done;
                                    p = f.next()
                                ) {
                                    var d = p.value
                                    if (!s.has(d))
                                        if (t.delete(d)) l = !0
                                        else {
                                            var v = t._data.get(d)
                                            u.set(d, v)
                                        }
                                }
                            } catch (e) {
                                n = { error: e }
                            } finally {
                                try {
                                    p && !p.done && (r = f.return) && r.call(f)
                                } finally {
                                    if (n) throw n.error
                                }
                            }
                            try {
                                for (var y = _(s.entries()), b = y.next(); !b.done; b = y.next()) {
                                    var g = E(b.value, 2),
                                        m = ((d = g[0]), (v = g[1]), t._data.has(d))
                                    if ((t.set(d, v), t._data.has(d))) {
                                        var w = t._data.get(d)
                                        u.set(d, w), m || (l = !0)
                                    }
                                }
                            } catch (e) {
                                i = { error: e }
                            } finally {
                                try {
                                    b && !b.done && (a = y.return) && a.call(y)
                                } finally {
                                    if (i) throw i.error
                                }
                            }
                            if (!l)
                                if (t._data.size !== u.size) t._keysAtom.reportChanged()
                                else
                                    for (
                                        var O = t._data.keys(),
                                            S = u.keys(),
                                            A = O.next(),
                                            x = S.next();
                                        !A.done;

                                    ) {
                                        if (A.value !== x.value) {
                                            t._keysAtom.reportChanged()
                                            break
                                        }
                                        ;(A = O.next()), (x = S.next())
                                    }
                            t._data = u
                        }),
                        this
                    )
                }),
                Object.defineProperty(e.prototype, "size", {
                    get: function() {
                        return this._keysAtom.reportObserved(), this._data.size
                    },
                    enumerable: !0,
                    configurable: !0
                }),
                (e.prototype.toPOJO = function() {
                    var e,
                        t,
                        n = {}
                    try {
                        for (var r = _(this), o = r.next(); !o.done; o = r.next()) {
                            var i = E(o.value, 2),
                                a = i[0],
                                s = i[1]
                            n["symbol" == typeof a ? a : v(a)] = s
                        }
                    } catch (t) {
                        e = { error: t }
                    } finally {
                        try {
                            o && !o.done && (t = r.return) && t.call(r)
                        } finally {
                            if (e) throw e.error
                        }
                    }
                    return n
                }),
                (e.prototype.toJS = function() {
                    return new Map(this)
                }),
                (e.prototype.toJSON = function() {
                    return this.toPOJO()
                }),
                (e.prototype.toString = function() {
                    var e = this
                    return (
                        this.name +
                        "[{ " +
                        Array.from(this.keys())
                            .map(function(t) {
                                return v(t) + ": " + e.get(t)
                            })
                            .join(", ") +
                        " }]"
                    )
                }),
                (e.prototype.observe = function(e, t) {
                    return kt(this, e)
                }),
                (e.prototype.intercept = function(e) {
                    return Rt(this, e)
                }),
                e
            )
        })(),
        Ht = f("ObservableMap", Kt),
        Wt = {},
        Jt = (function() {
            function e(e, t, n) {
                if (
                    (void 0 === t && (t = N),
                    void 0 === n && (n = "ObservableSet@" + r()),
                    (this.name = n),
                    (this[qt] = Wt),
                    (this._data = new Set()),
                    (this._atom = w(this.name)),
                    (this[Symbol.toStringTag] = "Set"),
                    "function" != typeof Set)
                )
                    throw new Error(
                        "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js"
                    )
                ;(this.enhancer = function(e, r) {
                    return t(e, r, n)
                }),
                    e && this.replace(e)
            }
            return (
                (e.prototype.dehanceValue = function(e) {
                    return void 0 !== this.dehancer ? this.dehancer(e) : e
                }),
                (e.prototype.clear = function() {
                    var e = this
                    St(function() {
                        ie(function() {
                            var t, n
                            try {
                                for (
                                    var r = _(e._data.values()), o = r.next();
                                    !o.done;
                                    o = r.next()
                                ) {
                                    var i = o.value
                                    e.delete(i)
                                }
                            } catch (e) {
                                t = { error: e }
                            } finally {
                                try {
                                    o && !o.done && (n = r.return) && n.call(r)
                                } finally {
                                    if (t) throw t.error
                                }
                            }
                        })
                    })
                }),
                (e.prototype.forEach = function(e, t) {
                    var n, r
                    try {
                        for (var o = _(this), i = o.next(); !i.done; i = o.next()) {
                            var a = i.value
                            e.call(t, a, a, this)
                        }
                    } catch (e) {
                        n = { error: e }
                    } finally {
                        try {
                            i && !i.done && (r = o.return) && r.call(o)
                        } finally {
                            if (n) throw n.error
                        }
                    }
                }),
                Object.defineProperty(e.prototype, "size", {
                    get: function() {
                        return this._atom.reportObserved(), this._data.size
                    },
                    enumerable: !0,
                    configurable: !0
                }),
                (e.prototype.add = function(e) {
                    var t = this
                    if (
                        (ne(this._atom), Ct(this)) &&
                        !(r = Tt(this, { type: "add", object: this, newValue: e }))
                    )
                        return this
                    if (!this.has(e)) {
                        St(function() {
                            t._data.add(t.enhancer(e, void 0)), t._atom.reportChanged()
                        })
                        var n = It(this),
                            r = n ? { type: "add", object: this, newValue: e } : null
                        n && Pt(this, r)
                    }
                    return this
                }),
                (e.prototype.delete = function(e) {
                    var t = this
                    if (Ct(this) && !(r = Tt(this, { type: "delete", object: this, oldValue: e })))
                        return !1
                    if (this.has(e)) {
                        var n = It(this),
                            r = n ? { type: "delete", object: this, oldValue: e } : null
                        return (
                            St(function() {
                                t._atom.reportChanged(), t._data.delete(e)
                            }),
                            n && Pt(this, r),
                            !0
                        )
                    }
                    return !1
                }),
                (e.prototype.has = function(e) {
                    return this._atom.reportObserved(), this._data.has(this.dehanceValue(e))
                }),
                (e.prototype.entries = function() {
                    var e = 0,
                        t = Array.from(this.keys()),
                        n = Array.from(this.values())
                    return ln({
                        next: function() {
                            var r = e
                            return (
                                (e += 1),
                                r < n.length ? { value: [t[r], n[r]], done: !1 } : { done: !0 }
                            )
                        }
                    })
                }),
                (e.prototype.keys = function() {
                    return this.values()
                }),
                (e.prototype.values = function() {
                    this._atom.reportObserved()
                    var e = this,
                        t = 0,
                        n = Array.from(this._data.values())
                    return ln({
                        next: function() {
                            return t < n.length
                                ? { value: e.dehanceValue(n[t++]), done: !1 }
                                : { done: !0 }
                        }
                    })
                }),
                (e.prototype.replace = function(e) {
                    var t = this
                    return (
                        Xt(e) && (e = e.toJS()),
                        St(function() {
                            Array.isArray(e)
                                ? (t.clear(),
                                  e.forEach(function(e) {
                                      return t.add(e)
                                  }))
                                : p(e)
                                ? (t.clear(),
                                  e.forEach(function(e) {
                                      return t.add(e)
                                  }))
                                : null != e && o("Cannot initialize set from " + e)
                        }),
                        this
                    )
                }),
                (e.prototype.observe = function(e, t) {
                    return kt(this, e)
                }),
                (e.prototype.intercept = function(e) {
                    return Rt(this, e)
                }),
                (e.prototype.toJS = function() {
                    return new Set(this)
                }),
                (e.prototype.toString = function() {
                    return this.name + "[ " + Array.from(this).join(", ") + " ]"
                }),
                (e.prototype[((qt = b), Symbol.iterator)] = function() {
                    return this.values()
                }),
                e
            )
        })(),
        Xt = f("ObservableSet", Jt),
        Yt = (function() {
            function e(e, t, n, r) {
                void 0 === t && (t = new Map()),
                    (this.target = e),
                    (this.values = t),
                    (this.name = n),
                    (this.defaultEnhancer = r),
                    (this.keysAtom = new g(n + ".keys"))
            }
            return (
                (e.prototype.read = function(e) {
                    return this.values.get(e).get()
                }),
                (e.prototype.write = function(e, t) {
                    var n = this.target,
                        r = this.values.get(e)
                    if (r instanceof Se) r.set(t)
                    else {
                        if (Ct(this)) {
                            if (
                                !(i = Tt(this, {
                                    type: "update",
                                    object: this.proxy || n,
                                    name: e,
                                    newValue: t
                                }))
                            )
                                return
                            t = i.newValue
                        }
                        if ((t = r.prepareNewValue(t)) !== Re.UNCHANGED) {
                            var o = It(this),
                                i = o
                                    ? {
                                          type: "update",
                                          object: this.proxy || n,
                                          oldValue: r.value,
                                          name: e,
                                          newValue: t
                                      }
                                    : null
                            0, r.setNewValue(t), o && Pt(this, i)
                        }
                    }
                }),
                (e.prototype.has = function(e) {
                    var t = this.pendingKeys || (this.pendingKeys = new Map()),
                        n = t.get(e)
                    if (n) return n.get()
                    var r = !!this.values.get(e)
                    return (
                        (n = new we(r, V, this.name + "." + v(e) + "?", !1)), t.set(e, n), n.get()
                    )
                }),
                (e.prototype.addObservableProp = function(e, t, n) {
                    void 0 === n && (n = this.defaultEnhancer)
                    var r = this.target
                    if (Ct(this)) {
                        var o = Tt(this, {
                            object: this.proxy || r,
                            name: e,
                            type: "add",
                            newValue: t
                        })
                        if (!o) return
                        t = o.newValue
                    }
                    var i = new we(t, n, this.name + "." + v(e), !1)
                    this.values.set(e, i),
                        (t = i.value),
                        Object.defineProperty(
                            r,
                            e,
                            (function(e) {
                                return (
                                    $t[e] ||
                                    ($t[e] = {
                                        configurable: !0,
                                        enumerable: !0,
                                        get: function() {
                                            return this[b].read(e)
                                        },
                                        set: function(t) {
                                            this[b].write(e, t)
                                        }
                                    })
                                )
                            })(e)
                        ),
                        this.notifyPropertyAddition(e, t)
                }),
                (e.prototype.addComputedProp = function(e, t, n) {
                    var r,
                        o,
                        i,
                        a = this.target
                    ;(n.name = n.name || this.name + "." + v(t)),
                        this.values.set(t, new Se(n)),
                        (e === a ||
                            ((r = e),
                            (o = t),
                            !(i = Object.getOwnPropertyDescriptor(r, o)) ||
                                (!1 !== i.configurable && !1 !== i.writable))) &&
                            Object.defineProperty(
                                e,
                                t,
                                (function(e) {
                                    return (
                                        Qt[e] ||
                                        (Qt[e] = {
                                            configurable: Re.computedConfigurable,
                                            enumerable: !1,
                                            get: function() {
                                                return Zt(this).read(e)
                                            },
                                            set: function(t) {
                                                Zt(this).write(e, t)
                                            }
                                        })
                                    )
                                })(t)
                            )
                }),
                (e.prototype.remove = function(e) {
                    if (this.values.has(e)) {
                        var t = this.target
                        if (Ct(this))
                            if (
                                !(a = Tt(this, {
                                    object: this.proxy || t,
                                    name: e,
                                    type: "remove"
                                }))
                            )
                                return
                        try {
                            Pe()
                            var n = It(this),
                                r = this.values.get(e),
                                o = r && r.get()
                            if (
                                (r && r.set(void 0),
                                this.keysAtom.reportChanged(),
                                this.values.delete(e),
                                this.pendingKeys)
                            ) {
                                var i = this.pendingKeys.get(e)
                                i && i.set(!1)
                            }
                            delete this.target[e]
                            var a = n
                                ? { type: "remove", object: this.proxy || t, oldValue: o, name: e }
                                : null
                            0, n && Pt(this, a)
                        } finally {
                            Ne()
                        }
                    }
                }),
                (e.prototype.illegalAccess = function(e, t) {
                    console.warn(
                        "Property '" +
                            t +
                            "' of '" +
                            e +
                            "' was accessed through the prototype chain. Use 'decorate' instead to declare the prop or access it statically through it's owner"
                    )
                }),
                (e.prototype.observe = function(e, t) {
                    return kt(this, e)
                }),
                (e.prototype.intercept = function(e) {
                    return Rt(this, e)
                }),
                (e.prototype.notifyPropertyAddition = function(e, t) {
                    var n = It(this),
                        r = n
                            ? {
                                  type: "add",
                                  object: this.proxy || this.target,
                                  name: e,
                                  newValue: t
                              }
                            : null
                    if ((n && Pt(this, r), this.pendingKeys)) {
                        var o = this.pendingKeys.get(e)
                        o && o.set(!0)
                    }
                    this.keysAtom.reportChanged()
                }),
                (e.prototype.getKeys = function() {
                    var e, t
                    this.keysAtom.reportObserved()
                    var n = []
                    try {
                        for (var r = _(this.values), o = r.next(); !o.done; o = r.next()) {
                            var i = E(o.value, 2),
                                a = i[0]
                            i[1] instanceof we && n.push(a)
                        }
                    } catch (t) {
                        e = { error: t }
                    } finally {
                        try {
                            o && !o.done && (t = r.return) && t.call(r)
                        } finally {
                            if (e) throw e.error
                        }
                    }
                    return n
                }),
                e
            )
        })()
    function Ft(e, t, n) {
        if (
            (void 0 === t && (t = ""),
            void 0 === n && (n = N),
            Object.prototype.hasOwnProperty.call(e, b))
        )
            return e[b]
        c(e) || (t = (e.constructor.name || "ObservableObject") + "@" + r()),
            t || (t = "ObservableObject@" + r())
        var o = new Yt(e, new Map(), v(t), n)
        return l(e, b, o), o
    }
    var $t = Object.create(null),
        Qt = Object.create(null)
    function Zt(e) {
        var t = e[b]
        return t || (I(e), e[b])
    }
    var en = f("ObservableObjectAdministration", Yt)
    function tn(e) {
        return !!u(e) && (I(e), en(e[b]))
    }
    function nn(e, t) {
        if ("object" == typeof e && null !== e) {
            if (Gt(e)) return void 0 !== t && o(!1), e[b].atom
            if (Xt(e)) return e[b]
            if (Ht(e)) {
                var n = e
                return void 0 === t
                    ? n._keysAtom
                    : ((r = n._data.get(t) || n._hasMap.get(t)) || o(!1), r)
            }
            var r
            if ((I(e), t && !e[b] && e[t], tn(e)))
                return t ? ((r = e[b].values.get(t)) || o(!1), r) : o(!1)
            if (m(e) || Ae(e) || qe(e)) return e
        } else if ("function" == typeof e && qe(e[b])) return e[b]
        return o(!1)
    }
    function rn(e, t) {
        return (
            e || o("Expecting some object"),
            void 0 !== t
                ? rn(nn(e, t))
                : m(e) || Ae(e) || qe(e)
                ? e
                : Ht(e) || Xt(e)
                ? e
                : (I(e), e[b] ? e[b] : void o(!1))
        )
    }
    function on(e, t) {
        return (void 0 !== t ? nn(e, t) : tn(e) || Ht(e) || Xt(e) ? rn(e) : nn(e)).name
    }
    var an = Object.prototype.toString
    function sn(e, t, n) {
        return (
            void 0 === n && (n = -1),
            (function e(t, n, r, o, i) {
                if (t === n) return 0 !== t || 1 / t == 1 / n
                if (null == t || null == n) return !1
                if (t != t) return n != n
                var a = typeof t
                if ("function" !== a && "object" !== a && "object" != typeof n) return !1
                var s = an.call(t)
                if (s !== an.call(n)) return !1
                switch (s) {
                    case "[object RegExp]":
                    case "[object String]":
                        return "" + t == "" + n
                    case "[object Number]":
                        return +t != +t ? +n != +n : 0 == +t ? 1 / +t == 1 / n : +t == +n
                    case "[object Date]":
                    case "[object Boolean]":
                        return +t == +n
                    case "[object Symbol]":
                        return (
                            "undefined" != typeof Symbol &&
                            Symbol.valueOf.call(t) === Symbol.valueOf.call(n)
                        )
                    case "[object Map]":
                    case "[object Set]":
                        r >= 0 && r++
                }
                ;(t = un(t)), (n = un(n))
                var u = "[object Array]" === s
                if (!u) {
                    if ("object" != typeof t || "object" != typeof n) return !1
                    var c = t.constructor,
                        l = n.constructor
                    if (
                        c !== l &&
                        !(
                            "function" == typeof c &&
                            c instanceof c &&
                            "function" == typeof l &&
                            l instanceof l
                        ) &&
                        "constructor" in t &&
                        "constructor" in n
                    )
                        return !1
                }
                if (0 === r) return !1
                r < 0 && (r = -1)
                i = i || []
                var f = (o = o || []).length
                for (; f--; ) if (o[f] === t) return i[f] === n
                if ((o.push(t), i.push(n), u)) {
                    if ((f = t.length) !== n.length) return !1
                    for (; f--; ) if (!e(t[f], n[f], r - 1, o, i)) return !1
                } else {
                    var h = Object.keys(t),
                        p = void 0
                    if (((f = h.length), Object.keys(n).length !== f)) return !1
                    for (; f--; )
                        if (((p = h[f]), !cn(n, p) || !e(t[p], n[p], r - 1, o, i))) return !1
                }
                return o.pop(), i.pop(), !0
            })(e, t, n)
        )
    }
    function un(e) {
        return Gt(e)
            ? e.slice()
            : h(e) || Ht(e)
            ? Array.from(e.entries())
            : p(e) || Xt(e)
            ? Array.from(e.entries())
            : e
    }
    function cn(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    function ln(e) {
        return (e[Symbol.iterator] = fn), e
    }
    function fn() {
        return this
    }
    if ("undefined" == typeof Proxy || "undefined" == typeof Symbol)
        throw new Error(
            "[mobx] MobX 5+ requires Proxy and Symbol objects. If your environment doesn't support Symbol or Proxy objects, please downgrade to MobX 4. For React Native Android, consider upgrading JSCore."
        )
    "object" == typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ &&
        __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
            spy: Ke,
            extras: { getDebugName: on },
            $mobx: b
        }),
        (e.$mobx = b),
        (e.FlowCancellationError = ct),
        (e.ObservableMap = Kt),
        (e.ObservableSet = Jt),
        (e.Reaction = Le),
        (e._allowStateChanges = function(e, t) {
            var n,
                r = ge(e)
            try {
                n = t()
            } finally {
                me(r)
            }
            return n
        }),
        (e._allowStateChangesInsideComputed = function(e) {
            var t,
                n = Re.computationDepth
            Re.computationDepth = 0
            try {
                t = e()
            } finally {
                Re.computationDepth = n
            }
            return t
        }),
        (e._allowStateReadsEnd = ce),
        (e._allowStateReadsStart = ue),
        (e._endAction = be),
        (e._getAdministration = rn),
        (e._getGlobalState = function() {
            return Re
        }),
        (e._interceptReads = function(e, t, n) {
            var r
            if (Ht(e) || Gt(e) || Oe(e)) r = rn(e)
            else {
                if (!tn(e)) return o(!1)
                if ("string" != typeof t) return o(!1)
                r = rn(e, t)
            }
            return void 0 !== r.dehancer
                ? o(!1)
                : ((r.dehancer = "function" == typeof t ? t : n),
                  function() {
                      r.dehancer = void 0
                  })
        }),
        (e._isComputingDerivation = function() {
            return null !== Re.trackingDerivation
        }),
        (e._resetGlobalState = function() {
            var e = new Ee()
            for (var t in e) -1 === _e.indexOf(t) && (Re[t] = e[t])
            Re.allowStateChanges = !Re.enforceActions
        }),
        (e._startAction = ye),
        (e.action = Xe),
        (e.autorun = Fe),
        (e.comparer = O),
        (e.computed = Q),
        (e.configure = function(e) {
            var t = e.enforceActions,
                n = e.computedRequiresReaction,
                r = e.computedConfigurable,
                i = e.disableErrorBoundaries,
                a = e.reactionScheduler,
                s = e.reactionRequiresObservable,
                u = e.observableRequiresReaction
            if (
                (!0 === e.isolateGlobalState &&
                    ((Re.pendingReactions.length || Re.inBatch || Re.isRunningReactions) &&
                        o(
                            "isolateGlobalState should be called before MobX is running any reactions"
                        ),
                    (Ce = !0),
                    je &&
                        (0 == --De().__mobxInstanceCount && (De().__mobxGlobals = void 0),
                        (Re = new Ee()))),
                void 0 !== t)
            ) {
                var c = void 0
                switch (t) {
                    case !0:
                    case "observed":
                        c = !0
                        break
                    case !1:
                    case "useMicrotasks":
                    case "never":
                        c = !1
                        break
                    case "strict":
                    case "always":
                        c = "strict"
                        break
                    default:
                        o(
                            "Invalid value for 'enforceActions': '" +
                                t +
                                "', expected 'never', 'always', 'observed' or 'useMicrotasks'"
                        )
                }
                ;(Re.enforceActions = c),
                    (Re.allowStateChanges = !0 !== c && "strict" !== c),
                    (Re.queueReportChangedEndBatchAsMicrotask = !0)
            }
            void 0 !== n && (Re.computedRequiresReaction = !!n),
                void 0 !== s && (Re.reactionRequiresObservable = !!s),
                void 0 !== u &&
                    ((Re.observableRequiresReaction = !!u),
                    (Re.allowStateReads = !Re.observableRequiresReaction)),
                void 0 !== r && (Re.computedConfigurable = !!r),
                void 0 !== i &&
                    (!0 === i &&
                        console.warn(
                            "WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled."
                        ),
                    (Re.disableErrorBoundaries = !!i)),
                a && ze(a)
        }),
        (e.createAtom = w),
        (e.decorate = function(e, t) {
            var n = "function" == typeof e ? e.prototype : e,
                r = function(e) {
                    var r = t[e]
                    Array.isArray(r) || (r = [r])
                    var o = Object.getOwnPropertyDescriptor(n, e),
                        i = r.reduce(function(t, r) {
                            return r(n, e, t)
                        }, o)
                    i && Object.defineProperty(n, e, i)
                }
            for (var o in t) r(o)
            return e
        }),
        (e.entries = function(e) {
            return tn(e)
                ? vt(e).map(function(t) {
                      return [t, e[t]]
                  })
                : Ht(e)
                ? vt(e).map(function(t) {
                      return [t, e.get(t)]
                  })
                : Xt(e)
                ? Array.from(e.entries())
                : Gt(e)
                ? e.map(function(e, t) {
                      return [t, e]
                  })
                : o(!1)
        }),
        (e.extendObservable = nt),
        (e.flow = function(e) {
            1 !== arguments.length && o("Flow expects 1 argument and cannot be used as decorator")
            var t = e.name || "<unnamed flow>"
            return function() {
                var n,
                    r = this,
                    o = arguments,
                    i = ++ut,
                    a = Xe(t + " - runid: " + i + " - init", e).apply(r, o),
                    u = void 0,
                    c = new Promise(function(e, r) {
                        var o = 0
                        function s(e) {
                            var n
                            u = void 0
                            try {
                                n = Xe(t + " - runid: " + i + " - yield " + o++, a.next).call(a, e)
                            } catch (e) {
                                return r(e)
                            }
                            l(n)
                        }
                        function c(e) {
                            var n
                            u = void 0
                            try {
                                n = Xe(t + " - runid: " + i + " - yield " + o++, a.throw).call(a, e)
                            } catch (e) {
                                return r(e)
                            }
                            l(n)
                        }
                        function l(t) {
                            if (!t || "function" != typeof t.then)
                                return t.done
                                    ? e(t.value)
                                    : (u = Promise.resolve(t.value)).then(s, c)
                            t.then(l, r)
                        }
                        ;(n = r), s(void 0)
                    })
                return (
                    (c.cancel = Xe(t + " - runid: " + i + " - cancel", function() {
                        try {
                            u && lt(u)
                            var e = a.return(void 0),
                                t = Promise.resolve(e.value)
                            t.then(s, s), lt(t), n(new ct())
                        } catch (e) {
                            n(e)
                        }
                    })),
                    c
                )
            }
        }),
        (e.get = function(e, t) {
            if (bt(e, t)) return tn(e) ? e[t] : Ht(e) ? e.get(t) : Gt(e) ? e[t] : o(!1)
        }),
        (e.getAtom = nn),
        (e.getDebugName = on),
        (e.getDependencyTree = it),
        (e.getObserverTree = function(e, t) {
            return st(nn(e, t))
        }),
        (e.has = bt),
        (e.intercept = function(e, t, n) {
            return "function" == typeof n
                ? (function(e, t, n) {
                      return rn(e, t).intercept(n)
                  })(e, t, n)
                : (function(e, t) {
                      return rn(e).intercept(t)
                  })(e, t)
        }),
        (e.isAction = function(e) {
            return "function" == typeof e && !0 === e.isMobxAction
        }),
        (e.isArrayLike = function(e) {
            return Array.isArray(e) || Gt(e)
        }),
        (e.isBoxedObservable = Oe),
        (e.isComputed = ht),
        (e.isComputedProp = function(e, t) {
            return "string" != typeof t ? o(!1) : ft(e, t)
        }),
        (e.isFlowCancellationError = function(e) {
            return e instanceof ct
        }),
        (e.isObservable = dt),
        (e.isObservableArray = Gt),
        (e.isObservableMap = Ht),
        (e.isObservableObject = tn),
        (e.isObservableProp = function(e, t) {
            return "string" != typeof t ? o(!1) : pt(e, t)
        }),
        (e.isObservableSet = Xt),
        (e.keys = vt),
        (e.observable = W),
        (e.observe = function(e, t, n, r) {
            return "function" == typeof n
                ? (function(e, t, n, r) {
                      return rn(e, t).observe(n, r)
                  })(e, t, n, r)
                : (function(e, t, n) {
                      return rn(e).observe(t, n)
                  })(e, t, n)
        }),
        (e.onBecomeObserved = Ze),
        (e.onBecomeUnobserved = et),
        (e.onReactionError = function(e) {
            return (
                Re.globalReactionErrorHandlers.push(e),
                function() {
                    var t = Re.globalReactionErrorHandlers.indexOf(e)
                    t >= 0 && Re.globalReactionErrorHandlers.splice(t, 1)
                }
            )
        }),
        (e.reaction = function(e, t, o) {
            void 0 === o && (o = n)
            var i,
                a,
                s,
                u = o.name || "Reaction@" + r(),
                c = Xe(
                    u,
                    o.onError
                        ? ((i = o.onError),
                          (a = t),
                          function() {
                              try {
                                  return a.apply(this, arguments)
                              } catch (e) {
                                  i.call(this, e)
                              }
                          })
                        : t
                ),
                l = !o.scheduler && !o.delay,
                f = Qe(o),
                h = !0,
                p = !1,
                d = o.compareStructural ? O.structural : o.equals || O.default,
                v = new Le(
                    u,
                    function() {
                        h || l ? y() : p || ((p = !0), f(y))
                    },
                    o.onError,
                    o.requiresObservable
                )
            function y() {
                if (((p = !1), !v.isDisposed)) {
                    var t = !1
                    v.track(function() {
                        var n = e(v)
                        ;(t = h || !d(s, n)), (s = n)
                    }),
                        h && o.fireImmediately && c(s, v),
                        h || !0 !== t || c(s, v),
                        h && (h = !1)
                }
            }
            return v.schedule(), v.getDisposer()
        }),
        (e.remove = function(e, t) {
            if (tn(e)) e[b].remove(t)
            else if (Ht(e)) e.delete(t)
            else if (Xt(e)) e.delete(t)
            else {
                if (!Gt(e)) return o(!1)
                "number" != typeof t && (t = parseInt(t, 10)),
                    i(t >= 0, "Not a valid index: '" + t + "'"),
                    e.splice(t, 1)
            }
        }),
        (e.runInAction = function(e, t) {
            return (
                "string" == typeof e || e.name, ve(0, "function" == typeof e ? e : t, this, void 0)
            )
        }),
        (e.set = yt),
        (e.spy = Ke),
        (e.toJS = function(e, t) {
            var n
            return (
                "boolean" == typeof t && (t = { detectCycles: t }),
                t || (t = gt),
                (t.detectCycles =
                    void 0 === t.detectCycles ? !0 === t.recurseEverything : !0 === t.detectCycles),
                t.detectCycles && (n = new Map()),
                (function e(t, n, r) {
                    if (!n.recurseEverything && !dt(t)) return t
                    if ("object" != typeof t) return t
                    if (null === t) return null
                    if (t instanceof Date) return t
                    if (Oe(t)) return e(t.get(), n, r)
                    if ((dt(t) && vt(t), !0 === n.detectCycles && null !== t && r.has(t)))
                        return r.get(t)
                    if (Gt(t) || Array.isArray(t)) {
                        var o = mt(r, t, [], n),
                            i = t.map(function(t) {
                                return e(t, n, r)
                            })
                        o.length = i.length
                        for (var a = 0, s = i.length; a < s; a++) o[a] = i[a]
                        return o
                    }
                    if (Xt(t) || Object.getPrototypeOf(t) === Set.prototype) {
                        if (!1 === n.exportMapsAsObjects) {
                            var u = mt(r, t, new Set(), n)
                            return (
                                t.forEach(function(t) {
                                    u.add(e(t, n, r))
                                }),
                                u
                            )
                        }
                        var c = mt(r, t, [], n)
                        return (
                            t.forEach(function(t) {
                                c.push(e(t, n, r))
                            }),
                            c
                        )
                    }
                    if (Ht(t) || Object.getPrototypeOf(t) === Map.prototype) {
                        if (!1 === n.exportMapsAsObjects) {
                            var l = mt(r, t, new Map(), n)
                            return (
                                t.forEach(function(t, o) {
                                    l.set(o, e(t, n, r))
                                }),
                                l
                            )
                        }
                        var f = mt(r, t, {}, n)
                        return (
                            t.forEach(function(t, o) {
                                f[o] = e(t, n, r)
                            }),
                            f
                        )
                    }
                    var h = mt(r, t, {}, n)
                    return (
                        d(t).forEach(function(o) {
                            h[o] = e(t[o], n, r)
                        }),
                        h
                    )
                })(e, t, n)
            )
        }),
        (e.trace = wt),
        (e.transaction = St),
        (e.untracked = ie),
        (e.values = function(e) {
            return tn(e)
                ? vt(e).map(function(t) {
                      return e[t]
                  })
                : Ht(e)
                ? vt(e).map(function(t) {
                      return e.get(t)
                  })
                : Xt(e)
                ? Array.from(e.values())
                : Gt(e)
                ? e.slice()
                : o(!1)
        }),
        (e.when = function(e, t, n) {
            return 1 === arguments.length || (t && "object" == typeof t)
                ? _t(e, t)
                : At(e, t, n || {})
        }),
        Object.defineProperty(e, "__esModule", { value: !0 })
})
